/// Copyright Â© 2009-2020 Frictional Games
/// Copyright 2023 Michael Pollind
/// SPDX-License-Identifier: GPL-3.0

#define PARALAX_MULTIPLIER 0.7

PUSH_CONSTANT(materialRootConstant, b0)
{
    DATA(uint, objectId, None);
    DATA(float, afT, None);
    DATA(uint,  blendMode,   None);
    DATA(uint,  textureMask, None);
    DATA(float, sceneAlpha, None);
    DATA(float, lightLevel, None);

};

CBUFFER(perFrameConstants, UPDATE_FREQ_PER_FRAME, b1, binding = 0)
{
    DATA(float4x4, invViewRotationMat, None);
    DATA(float4x4, viewMat, None);
    DATA(float4x4, invViewMat, None);
    DATA(float4x4, projMat, None);
    DATA(float4x4, viewProjMat, None);

    DATA(float, worldFogStart, None);
    DATA(float, worldFogLength, None);
    DATA(float, oneMinusFogAlpha, None);
    DATA(float, fogFalloffExp, None);
    DATA(float4, worldFogColor, None);

    DATA(float2, viewTexel, None);
    DATA(float2, viewportSize, None);
};

INLINE float3x3 ToNormalMat(float4x4 invModel, float4x4 invView) {
    //TODO fix for DIRECTX12
   return transpose(mul(float3x3(invModel[0].xyz, invModel[1].xyz, invModel[2].xyz), float3x3(invView[0].xyz, invView[1].xyz, invView[2].xyz)));
}

STRUCT(UniformObject) 
{
    DATA(float4x4, modelMat, None);
    DATA(float4x4, invModelMat, None);
    DATA(float4x4, uvMat, None);
    DATA(float, dissolveAmount, None);
    DATA(uint, materialID, None);
    DATA(uint, _pad0, None);
    DATA(uint, _pad1, None);
};

#if defined(MATERIAL_SOLID)
    // material data
    STRUCT(UniformMaterial) {
        DATA(uint, textureConfig, None);
        DATA(uint2, textureSampler, None); 
        DATA(float, heightMapScale, None);

        DATA(float, heightMapBias, None);
        DATA(float, frenselBias, None);
        DATA(float, frenselPow, None);
	    DATA(uint, _pad0, None);
	    
	    DATA(float4, _pad1, None);
    };
    INLINE bool HasDissolveFilter(uint _textureConfig)   { return (_textureConfig & (1 << 14)) != 0; }
    
#elif defined(MATERIAL_TRANSLUCENT)
    STRUCT(UniformMaterial) {
        DATA(uint, textureConfig, None);
        DATA(uint2, textureSampler, None);
        DATA(float, refractionScale, None);

        DATA(float, frenselBias, None);
        DATA(float, frenselPos, None);
        DATA(float, rimMulLight, None);
        DATA(float, rimMulPower, None);
	    
	    DATA(float4, _pad1, None);
    };

    INLINE bool UseRefractionNormals(uint _textureConfig)   { return (_textureConfig & (1 << 14)) != 0; }
    INLINE bool UseRefractionEdgeCheck(uint _textureConfig)   { return (_textureConfig & (1 << 15)) != 0; }
#elif defined(MATERIAL_WATER)
    STRUCT(UniformMaterial) {
        DATA(uint, textureConfig, None);
        DATA(uint2, textureSampler, None);
        DATA(float, refractionScale, None);

        DATA(float, frenselBias, None);
        DATA(float, frenselPow, None);
        DATA(float, reflectionFadeStart, None);
        DATA(float, reflectionFadeEnd, None);
        
        DATA(float, waveSpeed, None);
        DATA(float, waveAmplitude, None);
        DATA(float, waveFreq, None);
	    DATA(uint, _pad0, None);
    };
    
#else
     STRUCT(UniformMaterial) {
        DATA(uint, textureConfig, None);
        DATA(uint2, textureSampler, None);
	    DATA(uint, _pad0[9], None);
     };
#endif


#define BLEND_MODE_ADD 0
#define BLEND_MODE_MUL 1
#define BLEND_MODE_MULX2 2
#define BLEND_MODE_ALPHA 3
#define BLEND_MODE_PREMUL_ALPHA 4

RES(Buffer(UniformMaterial), uniformMaterialBuffer, UPDATE_FREQ_PER_FRAME, t0, binding = 1);
RES(Buffer(UniformObject), uniformObjectBuffer, UPDATE_FREQ_PER_FRAME, t1, binding = 2);

RES(SamplerState, nearestSampler, UPDATE_FREQ_NONE, s0, binding = 21);
RES(SamplerState, bilinearSampler, UPDATE_FREQ_NONE, s1, binding = 22);

RES(SamplerState, clampNearSampler, UPDATE_FREQ_NONE, s2, binding = 8);
RES(SamplerState, clampLinearSampler, UPDATE_FREQ_NONE, s3, binding = 9);
RES(SamplerState, clampTrilinearSampler, UPDATE_FREQ_NONE, s4, binding = 8);
RES(SamplerState, clampBorderNearSampler, UPDATE_FREQ_NONE, s5, binding = 9);
RES(SamplerState, clampBorderLinearSampler, UPDATE_FREQ_NONE, s6, binding = 8);
RES(SamplerState, clampBorderTrilinearSampler, UPDATE_FREQ_NONE, s7, binding = 9);
RES(SamplerState, repeatNearSampler, UPDATE_FREQ_NONE, s8, binding = 8);
RES(SamplerState, repeatLinearSampler, UPDATE_FREQ_NONE, s9, binding = 9);
RES(SamplerState, repeatTrilinearSampler, UPDATE_FREQ_NONE, s10, binding = 9);

RES(Tex2D(float4), diffuseMap, UPDATE_FREQ_PER_BATCH, t2, binding = 3); 
RES(Tex2D(float4), normalMap, UPDATE_FREQ_PER_BATCH, t3, binding = 5);
RES(Tex2D(float4), specularMap, UPDATE_FREQ_PER_BATCH, t4, binding = 7);
RES(Tex2D(float4), alphaMap, UPDATE_FREQ_PER_BATCH, t5, binding = 9);
RES(Tex2D(float4), heightMap, UPDATE_FREQ_PER_BATCH, t6, binding =  11);
RES(Tex2D(float4), illuminationMap, UPDATE_FREQ_PER_BATCH, t7, binding = 13);
RES(TexCube(float4), cubeMap, UPDATE_FREQ_PER_BATCH, t8, binding = 15);
RES(Tex2D(float4), dissolveAlphaMap, UPDATE_FREQ_PER_BATCH, t9, binding = 17);
RES(Tex2D(float4), cubeMapAlpha, UPDATE_FREQ_PER_BATCH, t10, binding = 19);

RES(Tex2D(float4), dissolveMap, UPDATE_FREQ_NONE, t11, binding = 23);
RES(Tex2D(float4), refractionMap, UPDATE_FREQ_PER_FRAME, t12, binding = 24); 
RES(Tex2D(float4), reflectionMap, UPDATE_FREQ_PER_FRAME, t13, binding = 25); 
 

float4 DIFFUSE_SamplerTex2D(Tex2D(float4) texture, uint samplerId, float2 pos) { 
    switch(samplerId) { 
        case 0:  return SampleTex2D(texture, Get(clampNearSampler), pos); 
        case 1:  return SampleTex2D(texture, Get(clampLinearSampler), pos); 
        case 2:  return SampleTex2D(texture, Get(clampTrilinearSampler ), pos); 
        case 3:  return SampleTex2D(texture, Get(clampBorderNearSampler), pos); 
        case 4:  return SampleTex2D(texture, Get(clampBorderLinearSampler), pos); 
        case 5:  return SampleTex2D(texture, Get(clampBorderTrilinearSampler), pos); 
        case 6:  return SampleTex2D(texture, Get(repeatNearSampler), pos); 
        case 7:  return SampleTex2D(texture, Get(repeatLinearSampler), pos); 
        case 8:  return SampleTex2D(texture, Get(repeatTrilinearSampler), pos); 
        default: break; 
    } 
    return SampleTex2D(texture, Get(clampLinearSampler), pos);
}

float4 DIFFUSE_SampleTexCube(TexCube(float4) texture, uint samplerId, float3 pos) {  
    switch(samplerId) { 
        case 0:  return SampleTexCube(texture, Get(clampNearSampler), pos); 
        case 1:  return SampleTexCube(texture, Get(clampLinearSampler), pos); 
        case 2:  return SampleTexCube(texture, Get(clampTrilinearSampler ), pos); 
        case 3:  return SampleTexCube(texture, Get(clampBorderNearSampler), pos); 
        case 4:  return SampleTexCube(texture, Get(clampBorderLinearSampler), pos); 
        case 5:  return SampleTexCube(texture, Get(clampBorderTrilinearSampler), pos); 
        case 6:  return SampleTexCube(texture, Get(repeatNearSampler), pos); 
        case 7:  return SampleTexCube(texture, Get(repeatLinearSampler), pos); 
        case 8:  return SampleTexCube(texture, Get(repeatTrilinearSampler), pos); 
        default: break; 
    } 
    return SampleTexCube(texture, Get(clampLinearSampler), pos);
}

INLINE uint diffuseMapSamplerID(uint _materialID) { return (Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x0000000F); }
INLINE uint normalMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x000000F0) >> 4); }
INLINE uint specularMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x00000F00) >> 8);}
INLINE uint alphaMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x0000F000) >> 12); }
INLINE uint heightMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x000F0000) >> 16); }
INLINE uint illuminationMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x00F00000) >> 20); }
INLINE uint cubeMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0x0F000000) >> 24); }
INLINE uint dissolveAlphaMapSamplerID(uint _materialID) { return ((Get(uniformMaterialBuffer)[_materialID].textureSampler.x & 0xF0000000) >> 28);}
INLINE uint cubeMapAlphaSamplerID(uint _materialID) { return (Get(uniformMaterialBuffer)[_materialID].textureSampler.y & 0x0000000F);}


float Fresnel(float afEDotN, float afFresnelBias, float afFresnelPow)
{
    float fFacing = 1.0 - afEDotN;
    return max(afFresnelBias+ (1.0-afFresnelBias)* pow(abs(fFacing),afFresnelPow), 0.0); 
}

float2 ParallaxRelief(uint materialID, int sampleCount, bool isSingleChannel, float heightMapScale, float3 normalizedNormal, float2 uv, float3 modelViewNormalizedDir) {
    //Get give normalizedView the length so it reaches bottom.
    float normalLength = 1.0 / modelViewNormalizedDir.z;
    modelViewNormalizedDir *= float3(normalLength, normalLength, normalLength);	
    

    //Apply scale and bias
    modelViewNormalizedDir.xy *= heightMapScale;
    float3 heightMapPos = float3(uv.xy, 0.0);

    //Determine number of steps based on angle between normal and eye
    int iterations = clamp(int(floor((1.0 - dot(modelViewNormalizedDir, normalizedNormal) ) * 18.0)) + 2, 0, 18); 
   
    if(iterations == 0) {
        return uv.xy;
    }

    // Do a linear search to find the first intersection
    {
        modelViewNormalizedDir /= float(iterations);
        for(int i = 0; i < (iterations - 1); i++) 
        { 

            float fDepth = isSingleChannel ? 
                DIFFUSE_SamplerTex2D(Get(heightMap), heightMapSamplerID(materialID), heightMapPos.xy).r: 
                DIFFUSE_SamplerTex2D(Get(heightMap), heightMapSamplerID(materialID), heightMapPos.xy).a; 
            if(heightMapPos.z < fDepth) {
                heightMapPos += modelViewNormalizedDir;
            }
        } 
    }

    // Do a binary search to find the exact intersection
    {
        for(int i=0; i < sampleCount; i++) 
        {
            float fDepth = isSingleChannel ?  
                DIFFUSE_SamplerTex2D(Get(heightMap), heightMapSamplerID(materialID), heightMapPos.xy).r:
                DIFFUSE_SamplerTex2D(Get(heightMap), heightMapSamplerID(materialID), heightMapPos.xy).a;
            if(heightMapPos.z < fDepth) {
                heightMapPos += modelViewNormalizedDir; 
            }

            modelViewNormalizedDir *= 0.5; 
            heightMapPos -= modelViewNormalizedDir; 
        }
    }

    return heightMapPos.xy;
}




#include "material_resource.h.fsl"

