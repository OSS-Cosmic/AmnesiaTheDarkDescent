#define MATERIAL_TRANSLUCENT 1
#include "translucency_resource.h.fsl"
#include "deferred_resources.h.fsl"
#include "deferred_common.h.fsl"

PUSH_CONSTANT(translucencyConstant, b0)
{
    DATA(int,  feature, None);
    DATA(float, sceneAlpha, None);
    DATA(float, lightLevel, None);
};

RES(Tex2D(float4), refractionMap, UPDATE_FREQ_PER_FRAME, t1, binding = 4); 

STRUCT(PsIn) 
{
    DATA(float4, Position, SV_Position);
    DATA(float3, pos, POSITION);
    DATA(float2, uv, TEXCOORD0);
    DATA(float3, normal, NORMAL);
    DATA(float3, tangent, TANGENT);
    DATA(float3, bitangent, BITANGENT);
    DATA(float4, color, COLOR);
};

STRUCT(PsOut)
{
	DATA(float4, diffuse, SV_Target0);
};


PsOut PS_MAIN(PsIn In)
{
    INIT_MAIN;
    PsOut Out;

    float4 finalColor = vec4(0.0, 0.0 ,0.0, 1.0);
 
    if(IsDiffuseEnable(Get(feature)) && HasDiffuse(Get(textureConfig))) {
        finalColor = SampleTex2D(Get(diffuseMap), Get(diffuseSampler), In.uv) * In.color;
    }
    int blend = GetBlend(Get(feature));

    float finalAlpha = 0.0;
    if(IsFogEnable(Get(feature))) {
        float fFogAmount =  pow(
            clamp(
                (-In.pos.z - Get(worldFogStart)) / Get(worldFogLength), 0.0, 1.0), Get(fogFalloffExp));
        finalAlpha = (Get(oneMinusFogAlpha) * fFogAmount + (1.0 - fFogAmount)) * Get(sceneAlpha);
    } else { 
        finalAlpha = Get(sceneAlpha);
    }

    ////////////////////
    //Calculate new color based on Alpha and Blend mode
    switch(blend) {
        case BLEND_MODE_ADD: 
            finalColor.xyz *= finalAlpha*Get(lightLevel);
            break;
        case BLEND_MODE_MUL:
            finalColor.xyz += (vec3(1.0,1.0, 1.0) - finalColor.xyz) * (1.0-finalAlpha);
            break;
        case BLEND_MODE_MULX2:
            float fBlendMulAlpha = Get(lightLevel) * finalAlpha;
            finalColor.xyz = mul(finalColor.xyz, fBlendMulAlpha) + mul(float3(0.5,0.5,0.5), (1.0 - fBlendMulAlpha));
            break;
        case BLEND_MODE_ALPHA:
            finalColor.xyz *= Get(lightLevel);
            finalColor.a *= finalAlpha;
            break;
        case BLEND_MODE_PREMUL_ALPHA:
           finalColor *= finalAlpha;
           finalColor.xyz *= Get(lightLevel);
            break;
    }

    bool useScreenNormal = IsRefractionNormalEnable(Get(feature)) && UseRefractionNormals(Get(textureConfig));

    float3 mapNormal = float3(0,0,0);
    float3 screenNormal = float3(0,0,0);

    if(IsRefractionEnable(Get(feature)) || (IsCubeMapEnable(Get(feature)) && HasCubeMap(Get(textureConfig) ))) {
        if(IsNormalEnable(Get(feature)) && HasNormal(Get(textureConfig))) {
            mapNormal = SampleTex2D(Get(normalMap), Get(normalSampler), In.uv).xyz * 2.0 - 1.0;
            screenNormal = normalize(mapNormal.x * In.tangent + mapNormal.y * In.bitangent + mapNormal.z * In.normal);
        } else {
            screenNormal = normalize(In.normal);
        }
    }
    
    if(IsRefractionEnable(Get(feature))) {
        float invDist = min(1.0/In.pos.z, 10.0);
        ///////////////////////
        // Sample refaraction map (using distorted coords)
        float2 distortedScreenPos = float2(0,0);
        if(IsNormalEnable(Get(feature)) && HasNormal(Get(textureConfig))) {
            float2 refractOffset = useScreenNormal ? screenNormal.xy : mapNormal.xy;
            distortedScreenPos += (In.Position.xy * Get(viewTexel)) + (refractOffset * Get(refractionScale) * invDist);
        } else {
            distortedScreenPos += (In.Position.xy * Get(viewTexel)) + (screenNormal.xy * Get(refractionScale) * invDist);
        }
        float4 refractionColor = SampleTex2D(Get(refractionMap), Get(nearestSampler), distortedScreenPos);

        ///////////////////////
        // Do blending in shader (blend mode is None with refraction)
        switch(blend) {
            case BLEND_MODE_ADD: 
                finalColor.xyz = finalColor.xyz + refractionColor.xyz;
                break;
            case BLEND_MODE_MUL:
                finalColor.xyz = finalColor.xyz * refractionColor.xyz;
                break;
            case BLEND_MODE_MULX2:
                finalColor.xyz = finalColor.xyz * refractionColor.xyz * 2.0;
                break;
            case BLEND_MODE_ALPHA:
                finalColor.xyz = finalColor.xyz * finalColor.a + refractionColor.xyz * (1.0 - finalColor.a);
                break;
            case BLEND_MODE_PREMUL_ALPHA:
                finalColor.xyz = finalColor.xyz + refractionColor.xyz * (1.0 - finalColor.a);
                break;
        }
    }

    if(IsCubeMapEnable(Get(feature)) && HasCubeMap(Get(textureConfig))) {
        float3 eyeVec = normalize(In.pos);
        
        float afEDotN = max(dot(-eyeVec, screenNormal),0.0);
        float fFresnel = Fresnel(afEDotN, Get(frenselBias), Get(frenselPos));
        
        float3 vEnvUv = reflect(eyeVec, screenNormal);
        vEnvUv = mul(Get(invViewRotationMat), float4(vEnvUv,1)).xyz;
                    
        float4 reflectionColor = SampleTexCube(Get(cubeMap),  Get(cubeSampler), vEnvUv);
        
        //Alpha for environment map
        if(IsCubeMapEnable(Get(feature)) && HasCubeMapAlpha(Get(textureConfig))) {
            float fEnvMapAlpha = SampleTex2D(Get(cubeMapAlpha), Get(cubeMapAlphaSampler), In.uv.xy).w;
            reflectionColor *= fEnvMapAlpha;
        }
        
        finalColor.xyz += reflectionColor.xyz * fFresnel * finalAlpha * Get(lightLevel);
        
        ///////////////////////////////
        //Rim reflections
        if(Get(rimMulLight) >0.0) 
        {
            float fRimLight = dot(screenNormal, vec3(0.0, 0.0, -1.0));
            fRimLight = pow(1.0 - abs(fRimLight), Get(rimMulPower)) * Get(rimMulLight);	
            
            finalColor.xyz += reflectionColor.xyz * fRimLight * finalAlpha * Get(lightLevel);
        }
    }

    Out.diffuse = finalColor;
    RETURN(Out);
}
