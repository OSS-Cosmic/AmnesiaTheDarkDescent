
RES(Tex2D(float), depthTest, UPDATE_FREQ_PER_FRAME, t0, binding = 0);
RES(SamplerState, depthSampler, UPDATE_FREQ_NONE, s0, binding = 15);

RES(RWBuffer(bool), occlusionTest, UPDATE_FREQ_PER_FRAME, u0, binding = 1);
RES(Buffer(float4), occlusionBoxBuffer, UPDATE_FREQ_PER_FRAME, t1, binding = 2);

CBUFFER(objectUniformBlock, UPDATE_FREQ_PER_FRAME, b0, binding = 3)
{ 
    DATA(uint2, depthDim, None);
    DATA(uint, numObjects, None);
    DATA(int, maxMipLevel, None);
};

CBUFFER(perFrameConstants, UPDATE_FREQ_PER_FRAME, b1, binding = 4)
{
    DATA(float4x4, invViewRotationMat, None);
    DATA(float4x4, viewMat, None);
    DATA(float4x4, invViewMat, None);
    DATA(float4x4, projMat, None);
    DATA(float4x4, viewProjMat, None);

    DATA(float, worldFogStart, None);
    DATA(float, worldFogLength, None);
    DATA(float, oneMinusFogAlpha, None);
    DATA(float, fogFalloffExp, None);
    DATA(float4, worldFogColor, None);

    DATA(float2, viewTexel, None);
    DATA(float2, viewportSize, None);
};



NUM_THREADS(128, 1,  1)
void CS_MAIN(SV_DispatchThreadID(uint3) did)
{
    INIT_MAIN;

    if(did.x >= Get(numObjects))
    {
        return;
    }
    float3 viewEye = -Get(viewMat)._m03_m13_m23;
    float3 bboxMin = Get(occlusionBoxBuffer)[(2 * did.x)].xyz;
    float3 bboxMax = Get(occlusionBoxBuffer)[(2 * did.x) + 1].xyz;

    float3 boxSize = (bboxMax.xyz - bboxMin.xyz);
    float3 boxCenter =  bboxMax.xyz + (boxSize / 2.0);
    float boxRadius = max(boxSize.x,max(boxSize.y,boxSize.z));
    //if(boxRadius < distance(viewEye, boxCenter)) {
    //    Get(occlusionTest)[did.x] = true;
    //    return;
    //}

    //Adapted from http://blog.selfshadow.com/publications/practical-visibility/
    float3 boxCorners[] = {
        float3(bboxMax.x,bboxMax.y,bboxMax.z),
		float3(bboxMax.x,bboxMax.y,bboxMin.z),
		float3(bboxMax.x,bboxMin.y,bboxMax.z),
		float3(bboxMax.x,bboxMin.y,bboxMin.z),
		float3(bboxMin.x,bboxMax.y,bboxMax.z),
		float3(bboxMin.x,bboxMax.y,bboxMin.z),
		float3(bboxMin.x,bboxMin.y,bboxMax.z),
		float3(bboxMin.x,bboxMin.y,bboxMin.z)
    };


    float minZ = 1.0;
    float2 minXY = float2(1.0, 1.0);
    float2 maxXY = float2(0.0, 0.0);
    UNROLL
    for (uint k = 0; k < 8; k++)
    {
        //transform World space aaBox to NDC
        float4 clipPos = mul(Get(viewProjMat), float4(boxCorners[k].xyz, 1.0));
		
		clipPos.xyz = clipPos.xyz / clipPos.w;
      	clipPos.z = max(clipPos.z, 0);

		clipPos.xy = clamp(clipPos.xy, -1, 1);
		clipPos.xy = (clipPos.xy * float2(0.5, -0.5)) + float2(0.5, 0.5);	
        
        minXY = min(clipPos.xy, minXY);
        maxXY = max(clipPos.xy, maxXY);
        minZ = saturate(min(minZ, clipPos.z));
    }


    //TODO fix for DIRECTX12
    int2 rtSize = int2(Get(viewportSize).xy);
    int2 size = int2((maxXY - minXY) * rtSize);
    float mip = floor(log2(max(size.x, size.y)));

    //mip = clamp(mip, 0, Get(maxMipLevel));
    
    // Texel footprint for the lower (finer-grained) level
    float level_lower = max(mip - 1, 0);
    
    float2 scale = exp2(-level_lower).xx;
    float2 a = floor(minXY.xy * scale);
    float2 b = ceil(maxXY.xy * scale);
    float2 dims = b - a;
    
    // Use the lower level if we only touch <= 2 texels in both dimensions
    if (dims.x <= 2.0 && dims.y <= 2.0)  {
        mip = level_lower;
    }
    
    //Get(occlusionTest)[did.x] = false;
    float2 texelSize = 1.0 / floor(float2(rtSize) * exp2(-mip).xx);
    //for(float i = minXY.x; i <= maxXY.x; i += texelSize.x)
    //{
    //    for(float j = minXY.y; j <= maxXY.y; j += texelSize.y)
    //    {
    //        float depth  = SampleLvlTex2D( Get(depthTest), Get(depthSampler), float2(i,j), mip);
    //        if(minZ <= (depth + 0.001)) {
    //            Get(occlusionTest)[did.x] = true;
    //            return;
    //        }
    //    }
    //}

    
    float maxDepth;
    maxDepth = max(maxDepth, SampleLvlTex2D( Get(depthTest), Get(depthSampler), minXY, mip));
    maxDepth = max(maxDepth, SampleLvlTex2D( Get(depthTest), Get(depthSampler), maxXY, mip));
    maxDepth = max(maxDepth, SampleLvlTex2D( Get(depthTest), Get(depthSampler), float2(minXY.x, maxXY.y), mip));
    maxDepth = max(maxDepth, SampleLvlTex2D( Get(depthTest), Get(depthSampler), float2(maxXY.x, minXY.y), mip));

    Get(occlusionTest)[did.x] = minZ <= (maxDepth + 0.01);

}
