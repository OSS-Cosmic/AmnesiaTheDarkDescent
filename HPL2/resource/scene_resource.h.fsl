#include "scene_defs.h.fsl"

CBUFFER(sceneInfo, UPDATE_FREQ_PER_FRAME, b0, binding = 0) {
  DATA(WorldInfo, worldInfo, None);
  DATA(ViewportInfo, viewports[64], None);
};
RES(Buffer(UniformObject), sceneObjects, UPDATE_FREQ_PER_FRAME, t1, binding = 1);

// indirect DrawArg to resolve the triangle
RES(Buffer(uint), indirectDrawArgs, UPDATE_FREQ_PER_FRAME, t2, binding = 2);

// opaque geometry set
RES(ByteBuffer,   vtxOpaqueIndex,     UPDATE_FREQ_NONE, t2, binding = 3);
RES(ByteBuffer,   vtxOpaquePosition,  UPDATE_FREQ_NONE, t2, binding = 3);
RES(ByteBuffer,   vtxOpaqueTangnet,   UPDATE_FREQ_NONE, t3, binding = 4);
RES(ByteBuffer,   vtxOpaqueNormal,    UPDATE_FREQ_NONE, t4, binding = 5);
RES(ByteBuffer,   vtxOpaqueUv,        UPDATE_FREQ_NONE, t4, binding = 6);
RES(ByteBuffer,   vtxOpaqueColor,     UPDATE_FREQ_NONE, t4, binding = 7);

RES(Buffer(DiffuseMaterial), sceneDiffuseMat, UPDATE_FREQ_NONE, t0, binding = 8);

RES(SamplerState,  linearBorderClamp, UPDATE_FREQ_PER_FRAME, s1, binding = 9);
RES(Tex2D(float4), visibilityTexture,      UPDATE_FREQ_PER_FRAME, t0, binding = 10);

RES(SamplerState, sceneFilters[SCENE_MAX_FILTER_COUNT], UPDATE_FREQ_NONE, s1, binding = 20); 
RES(Tex2D(float4), sceneTextures[SCENE_MAX_TEXTURE_COUNT],  UPDATE_FREQ_PER_FRAME, t5, binding = 20 + SCENE_MAX_FILTER_COUNT);

#define SCENE_OBJECT_ID_BIT 19 // 13  bits for ObjectID 
#define SCENE_PRIM_ID_BIT  0 // 19 bits for PrimitiveID

#define SCENE_OBJECT_ID_MASK 0xFFF80000 // 1111 1111 1111 1000 0000 0000 0000 0000
#define SCENE_PRIM_ID_MASK 0x0007FFFF   // 0000 0000 0000 0111 1111 1111 1111 1111
#define SCENE_VIZ_ID(objectId, primitiveId) (((objectId << SCENE_OBJECT_ID_BIT) & SCENE_OBJECT_ID_MASK) | ((primitiveId << SCENE_PRIM_ID_BIT) & SCENE_PRIM_ID_MASK)) 

#define SCENE_VIZ_OBJECT_ID(id) (((id) & SCENE_OBJECT_ID_MASK) >> SCENE_OBJECT_ID_BIT)
#define SCENE_VIZ_PRIM_ID(id) (((id) & SCENE_PRIM_ID_MASK) >> SCENE_OBJECT_ID_BIT)

INLINE bool fetchSceneTextureFloat4(uint filterIdx, uint textureIdx, float2 uv, inout float4 value) { 
    switch(filterIdx) {
        SCENE_FILTER_SWITCH_CASE { 
            if(textureIdx < SCENE_MAX_TEXTURE_COUNT) {
                BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_COUNT);
                    value = SampleTex2D(Get(sceneTextures)[textureIdx], Get(sceneFilters)[filterIdx], uv);
                EndNonUniformResourceIndex(); 
            }
            break;
        }
        default:
            break;
    }
    return !(textureIdx == INVALID_TEXTURE_INDEX); 
}

INLINE bool fetchSceneTextureFloat3(uint filterIdx, uint textureIdx, float2 uv, inout float3 value) { 
    switch(filterIdx) {
        SCENE_FILTER_SWITCH_CASE { 
            if(textureIdx < SCENE_MAX_TEXTURE_COUNT) {
                BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_COUNT);
                    value = SampleTex2D(Get(sceneTextures)[textureIdx], Get(sceneFilters)[filterIdx], uv).xyz;
                EndNonUniformResourceIndex(); 
            }
            break;
        }
        default:
            break;
    }
    return !(textureIdx == INVALID_TEXTURE_INDEX); 
}

INLINE bool fetchSceneTextureFloat2(uint filterIdx, uint textureIdx, float2 uv, inout float2 value) { 
    switch(filterIdx) {
        SCENE_FILTER_SWITCH_CASE { 
            if(textureIdx < SCENE_MAX_TEXTURE_COUNT) {
                BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_COUNT);
                    value = SampleTex2D(Get(sceneTextures)[textureIdx], Get(sceneFilters)[filterIdx], uv).xy;
                EndNonUniformResourceIndex(); 
            }
        break;
    }
    default:
        break;
    }
    return !(textureIdx == INVALID_TEXTURE_INDEX); 
}

