#include "scene_defs.h.fsl"

#ifndef _SCENE_RESOURCE_H
#define _SCENE_RESOURCE_H

#if defined(DIRECT3D12)
	PUSH_CONSTANT(indirectRootConstant, b0)
	{
		DATA(uint, indirectDrawId, None);
	};

	#define INDIRECT_ROOT_CONSTANT 1
#endif

RES(SamplerState,  nearEdgeClampSampler, UPDATE_FREQ_NONE, s0, binding = 0);
RES(SamplerState,  nearPointWrapSampler, UPDATE_FREQ_NONE, s1, binding = 1);
RES(SamplerState,  linearBorderSampler, UPDATE_FREQ_NONE, s2, binding = 2);
RES(SamplerComparisonState,  shadowCmpSampler, UPDATE_FREQ_NONE, s3, binding = 3);
RES(SamplerState, sceneSampler, UPDATE_FREQ_NONE, s4, binding = 4); 

CBUFFER(sceneInfo, UPDATE_FREQ_PER_FRAME, b1, binding = 5) {
  DATA(WorldInfo, worldInfo, None);
};

CBUFFER(uniformBlock_rootcbv, UPDATE_FREQ_NONE, b2, binding = 6) {
  DATA(ViewportInfo, viewport, None);
};

RES(Buffer(UniformObject), sceneObjects, UPDATE_FREQ_PER_FRAME, t0, binding = 7);
RES(Buffer(Light), lights,               UPDATE_FREQ_PER_FRAME, t1, binding = 8);
RES(Buffer(Particle), particles,         UPDATE_FREQ_PER_FRAME, t2, binding = 9);
RES(Buffer(Decal), decals,               UPDATE_FREQ_PER_FRAME, t3, binding = 10);

// opaque geometry set
RES(ByteBuffer,   vtxOpaqueIndex,     UPDATE_FREQ_NONE, t4, binding = 11);
RES(ByteBuffer,   vtxOpaquePosition,  UPDATE_FREQ_NONE, t5, binding = 12);
RES(ByteBuffer,   vtxOpaqueTangnet,   UPDATE_FREQ_NONE, t6, binding = 13);
RES(ByteBuffer,   vtxOpaqueNormal,    UPDATE_FREQ_NONE, t7, binding = 14);
RES(ByteBuffer,   vtxOpaqueUv,        UPDATE_FREQ_NONE, t8, binding = 15);
RES(ByteBuffer,   vtxOpaqueColor,     UPDATE_FREQ_NONE, t9, binding = 16);

RES(Buffer(DiffuseMaterial), sceneDiffuseMat, UPDATE_FREQ_NONE, t10, binding = 17);
RES(Buffer(TranslucentMaterial), sceneTranslucentMat, UPDATE_FREQ_NONE, t11, binding = 18);
RES(Buffer(WaterMaterial), sceneWaterMat, UPDATE_FREQ_NONE, t12, binding = 19);

RES(Tex2D(float4), shadowTexture, UPDATE_FREQ_NONE, t13, binding = 20);
RES(Tex2D(float4), visibilityTexture,   UPDATE_FREQ_PER_FRAME, t14, binding = 21);
RES(Tex2D(float4), albedoTexture,      UPDATE_FREQ_PER_FRAME, t15, binding = 22);
RES(Tex2D(float4), refractionTexture,      UPDATE_FREQ_PER_FRAME, t16, binding = 23);
RES(Tex2D(float4), reflectionTexture[SCENE_MAX_REFLECTION_COUNT],      UPDATE_FREQ_PER_FRAME, t17, binding = 24);

RES(Tex2D(float4), dissolveTexture,    UPDATE_FREQ_NONE, t22, binding = 25);

RES(ByteBuffer, lightClustersCount, UPDATE_FREQ_PER_FRAME, t23, binding = 26);
RES(ByteBuffer, lightClusters,      UPDATE_FREQ_PER_FRAME, t24, binding = 27);

RES(Tex2D(float4), sceneTextures[SCENE_MAX_TEXTURE_COUNT],  UPDATE_FREQ_PER_FRAME, t25, binding = 28);
RES(TexCube(float4), sceneCubeTextures[SCENE_MAX_TEXTURE_CUBE_COUNT],  UPDATE_FREQ_PER_FRAME, t10025, binding = 29);

#define SCENE_OBJECT_ID_BIT 19 // 13  bits for ObjectID 
#define SCENE_PRIM_ID_BIT  0 // 19 bits for PrimitiveID

// reserve a bit for alpha
#define SCENE_ALPHA_MASK_FLAG 0x80000000   // 1111 1111 1111 1000 0000 0000 0000 0000
#define SCENE_OBJECT_ID_MASK  0x7FF80000   // 1111 1111 1111 1000 0000 0000 0000 0000 
#define SCENE_PRIM_ID_MASK    0x0007FFFF   // 0000 0000 0000 0111 1111 1111 1111 1111

#define SCENE_VIZ_ALPHA_ID(objectId, primitiveId) ((SCENE_ALPHA_MASK_FLAG) | ((objectId << SCENE_OBJECT_ID_BIT) & SCENE_OBJECT_ID_MASK) | ((primitiveId << SCENE_PRIM_ID_BIT) & SCENE_PRIM_ID_MASK)) 
#define SCENE_VIZ_ID(objectId, primitiveId) (((objectId << SCENE_OBJECT_ID_BIT) & SCENE_OBJECT_ID_MASK) | ((primitiveId << SCENE_PRIM_ID_BIT) & SCENE_PRIM_ID_MASK)) 

#define SCENE_VIZ_OBJECT_ID(id) (((id) & SCENE_OBJECT_ID_MASK) >> SCENE_OBJECT_ID_BIT)
#define SCENE_VIZ_PRIM_ID(id) (((id) & SCENE_PRIM_ID_MASK) >> SCENE_PRIM_ID_BIT)

#endif
