#include "scene_defs.h.fsl"

#ifndef _SCENE_RESOURCE_H
#define _SCENE_RESOURCE_H

#if defined(DIRECT3D12)
	PUSH_CONSTANT(indirectRootConstant, b1)
	{
		DATA(uint, indirectDrawId, None);
	};

	#define INDIRECT_ROOT_CONSTANT 1
#endif

CBUFFER(sceneInfo, UPDATE_FREQ_PER_FRAME, b2, binding = 0) {
  DATA(WorldInfo, worldInfo, None);
  DATA(ViewportInfo, viewports[64], None);
};

RES(Buffer(UniformObject), sceneObjects, UPDATE_FREQ_PER_FRAME, t0, binding = 1);
RES(Buffer(Light), lights,               UPDATE_FREQ_PER_FRAME, t1, binding = 2);
RES(Buffer(Particle), particles,         UPDATE_FREQ_PER_FRAME, t2, binding = 3);
RES(Buffer(Decal), decals,               UPDATE_FREQ_PER_FRAME, t3, binding = 4);

// opaque geometry set
RES(ByteBuffer,   vtxOpaqueIndex,     UPDATE_FREQ_NONE, t4, binding = 5);
RES(ByteBuffer,   vtxOpaquePosition,  UPDATE_FREQ_NONE, t5, binding = 6);
RES(ByteBuffer,   vtxOpaqueTangnet,   UPDATE_FREQ_NONE, t6, binding = 7);
RES(ByteBuffer,   vtxOpaqueNormal,    UPDATE_FREQ_NONE, t7, binding = 8);
RES(ByteBuffer,   vtxOpaqueUv,        UPDATE_FREQ_NONE, t8, binding = 9);
RES(ByteBuffer,   vtxOpaqueColor,     UPDATE_FREQ_NONE, t9, binding = 10);

RES(Buffer(DiffuseMaterial), sceneDiffuseMat, UPDATE_FREQ_NONE, t10, binding = 11);
RES(Buffer(TranslucentMaterial), sceneTranslucentMat, UPDATE_FREQ_NONE, t10, binding = 12);
RES(Buffer(WaterMaterial), sceneWaterMat, UPDATE_FREQ_NONE, t10, binding = 13);

RES(SamplerState,  nearEdgeClampSampler, UPDATE_FREQ_NONE, s0, binding = 14);
RES(SamplerState,  nearPointWrapSampler, UPDATE_FREQ_NONE, s1, binding = 15);
RES(SamplerState,  linearBorderSampler, UPDATE_FREQ_NONE, s1, binding = 16);

RES(Tex2D(float4), visibilityTexture,   UPDATE_FREQ_PER_FRAME, t11, binding = 17);
RES(Tex2D(float4), albedoTexture,      UPDATE_FREQ_PER_FRAME, t12, binding = 18);
RES(Tex2D(float4), refractionTexture,      UPDATE_FREQ_PER_FRAME, t12, binding = 19);

RES(Tex2D(float4), dissolveTexture,    UPDATE_FREQ_NONE, t14, binding = 20);

RES(ByteBuffer, lightClustersCount, UPDATE_FREQ_PER_FRAME, t15, binding = 21);
RES(ByteBuffer, lightClusters,      UPDATE_FREQ_PER_FRAME, t16, binding = 22);

RES(SamplerState, sceneSampler, UPDATE_FREQ_NONE, s2, binding = 23); 
RES(Tex2D(float4), sceneTextures[SCENE_MAX_TEXTURE_COUNT],  UPDATE_FREQ_PER_FRAME, t17, binding = 24);
RES(TexCube(float4), sceneCubeTextures[SCENE_MAX_TEXTURE_CUBE_COUNT],  UPDATE_FREQ_PER_FRAME, t18, binding = 25 + SCENE_MAX_TEXTURE_COUNT);

#define SCENE_OBJECT_ID_BIT 19 // 13  bits for ObjectID 
#define SCENE_PRIM_ID_BIT  0 // 19 bits for PrimitiveID

// reserve a bit for alpha
#define SCENE_ALPHA_MASK_FLAG 0x80000000   // 1111 1111 1111 1000 0000 0000 0000 0000
#define SCENE_OBJECT_ID_MASK  0x7FF80000   // 1111 1111 1111 1000 0000 0000 0000 0000 
#define SCENE_PRIM_ID_MASK    0x0007FFFF   // 0000 0000 0000 0111 1111 1111 1111 1111

#define SCENE_VIZ_ALPHA_ID(objectId, primitiveId) ((SCENE_ALPHA_MASK_FLAG) | ((objectId << SCENE_OBJECT_ID_BIT) & SCENE_OBJECT_ID_MASK) | ((primitiveId << SCENE_PRIM_ID_BIT) & SCENE_PRIM_ID_MASK)) 
#define SCENE_VIZ_ID(objectId, primitiveId) (((objectId << SCENE_OBJECT_ID_BIT) & SCENE_OBJECT_ID_MASK) | ((primitiveId << SCENE_PRIM_ID_BIT) & SCENE_PRIM_ID_MASK)) 

#define SCENE_VIZ_OBJECT_ID(id) (((id) & SCENE_OBJECT_ID_MASK) >> SCENE_OBJECT_ID_BIT)
#define SCENE_VIZ_PRIM_ID(id) (((id) & SCENE_PRIM_ID_MASK) >> SCENE_PRIM_ID_BIT)

bool SampleSceneTextureProjFloat4(uint textureIdx, SamplerState sh, float4 projectUV, inout float4 value) {
    if(textureIdx < SCENE_MAX_TEXTURE_COUNT) {
        BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_COUNT);
            value = SampleTex2DProj(Get(sceneTextures)[textureIdx], sh, projectUV);
        EndNonUniformResourceIndex(); 
        return true;
    }
    return false;
}

bool SampleSceneCubeTextureFloat4(uint textureIdx, SamplerState sh, float3 uv, inout float4 value) {
    if(textureIdx < SCENE_MAX_TEXTURE_CUBE_COUNT) {
        BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_CUBE_COUNT);
            value = SampleTexCube(Get(sceneCubeTextures)[textureIdx], sh, uv);
	    EndNonUniformResourceIndex();
        return true;
    }
    return false;
}

bool SampleSceneTextureFloat4(uint textureIdx,SamplerState sh, float2 uv, inout float4 value) {
    if(textureIdx < SCENE_MAX_TEXTURE_COUNT) {
        BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_COUNT);
            value = SampleTex2D(Get(sceneTextures)[textureIdx], sh, uv);
	    EndNonUniformResourceIndex();
        return true;
    }
    return false;
}
bool SampleSceneTextureGradFloat4(uint textureIdx, SamplerState sh, float2 uv, float2 texCoordDX, float2 texCoordDY, inout float4 value) {
    if(textureIdx < SCENE_MAX_TEXTURE_COUNT) {
        BeginNonUniformResourceIndex(textureIdx, SCENE_MAX_TEXTURE_COUNT);
	        value = SampleGradTex2D(Get(sceneTextures)[textureIdx], sh, uv, texCoordDX, texCoordDY);
        EndNonUniformResourceIndex(); 
        return true;
    }
    return false;
}

#endif
