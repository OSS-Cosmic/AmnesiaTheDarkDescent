#include "scene_light_cluster_resource.h.fsl"
#include "math_utils.h.fsl"


NUM_THREADS(LIGHT_CLUSTER_WIDTH, LIGHT_CLUSTER_HEIGHT, 1)
void CS_MAIN(SV_GroupThreadID(uint3) threadInGroupId, SV_GroupID(uint3) groupId)
{
	INIT_MAIN;
	const float invClusterWidth  = 1.0f / float(LIGHT_CLUSTER_WIDTH);
	const float invClusterHeight = 1.0f / float(LIGHT_CLUSTER_HEIGHT);
  
  ViewportInfo viewInfo = Get(viewports)[PRIMARY_VIEWPORT_INDEX];
	mat4 invProjMat = mul(viewInfo.viewMat, viewInfo.invViewProj);
  //float4x4 viewProjMat = mul(viewInfo.projMat, viewInfo.viewMat);
  float2 screenDim = viewInfo.rect.zw;

  //Near and far values of the cluster in view space
	
	const float tileNear = -getDepthClipPlane(float(groupId.z), LIGHT_CLUSTER_SLICE, viewInfo.zNear, viewInfo.zFar);
	const float tileFar = -getDepthClipPlane(float(groupId.z) + 1.0, LIGHT_CLUSTER_SLICE, viewInfo.zNear, viewInfo.zFar);

	// Cluster coordinates in post perspective clip space
	// Transform coordinates from range [0..1] to range [-1..1]
	float clusterLeft   = (float(threadInGroupId.x) * invClusterWidth) * 2.0f - 1.0f;
	float clusterTop    = (float(threadInGroupId.y) * invClusterHeight) * 2.0f - 1.0f;
	float clusterRight  = (clusterLeft + invClusterWidth) * 2.0f - 1.0f;
	float clusterBottom = (clusterTop + invClusterHeight) * 2.0f - 1.0f;

	clusterTop *= -1.0;
	clusterBottom *= -1.0;

	float3 minPointViewSpace = ndcToViewSpace(float4(clusterLeft, clusterTop, -1.0, 1.0), viewInfo.invProjMat).xyz;
	float3 maxPointViewSpace = ndcToViewSpace(float4(clusterRight, clusterBottom, -1.0, 1.0), viewInfo.invProjMat).xyz;

	float3 viewSpaceNearP1 = lineIntersectionToZPlane(float3(0,0,0), minPointViewSpace, tileNear);
	float3 viewSpaceNearP2 = lineIntersectionToZPlane(float3(0,0,0), maxPointViewSpace , tileNear);
	float3 viewSpaceFarP1 = lineIntersectionToZPlane(float3(0,0,0), minPointViewSpace, tileFar);
	float3 viewSpaceFarP2 = lineIntersectionToZPlane(float3(0,0,0), maxPointViewSpace, tileFar);

	float3 minPointAABB = min(min(viewSpaceNearP1, viewSpaceNearP2), min(viewSpaceFarP1, viewSpaceFarP2));
	float3 maxPointAABB = max(max(viewSpaceNearP1, viewSpaceNearP2), max(viewSpaceFarP1, viewSpaceFarP2));
	
  PointLight lightData = Get(pointLights)[groupId.x];
	float4 lightViewPos = mul(viewInfo.viewMat, float4(lightData.lightPos.xyz, 1.0f));
  if (testSphereAABB(lightViewPos.xyz, lightData.lightRadius, minPointAABB, maxPointAABB)) {
  	// Increase light count on this cluster
  	uint lightArrayPos = 0;
  	AtomicAdd(Get(lightClustersCount)[LIGHT_FROXEL_COUNT_POS(threadInGroupId.x, threadInGroupId.y, groupId.z)], 1, lightArrayPos);

  	// Add light id to cluster
  	AtomicExchange(Get(lightClusters)[LIGHT_FROXEL_DATA_POS(threadInGroupId.x, threadInGroupId.y, groupId.z, lightArrayPos)], groupId.x, lightArrayPos);
  }

}

