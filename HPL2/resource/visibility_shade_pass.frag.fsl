#include "scene_resource.h.fsl"
#include "packing.h.fsl"
#include "visiblity_defs.h.fsl"

STRUCT(PsIn)
{
	DATA(float4, position,  SV_Position);
	DATA(float2, screenPos, TEXCOORD0);
};


float4 PS_MAIN(PsIn In)
{
	INIT_MAIN;
	
	float4 visRaw = LoadTex2D(Get(visibilityTexture), Get(linearBorderClamp), uint2(In.position.xy), 0);
	// Unpack float4 render target data into uint to extract data
	uint objectId_triId = packUnorm4x8(visRaw);
	uint objectId = SCENE_VIZ_OBJECT_ID(objectId_triId);
	uint triId = SCENE_VIZ_PRIM_ID(objectId_triId);

	if(objectId_triId == ~0u) {
		discard;
	}

	UniformObject obj = Get(sceneObjects)[objectId];
	uint startIndex = Get(indirectDrawArgs)[obj.indirectDrawOffset + INDIRECT_DRAW_ARGUMENTS_START_INDEX_OFFSET];
	uint vertexOffset = Get(indirectDrawArgs)[obj.indirectDrawOffset + INDIRECT_DRAW_ARGUMENTS_VERTEX_OFFSET_OFFSET];
  ViewportInfo info = Get(viewports)[PRIMARY_VIEWPORT_INDEX];

	//uint materialID = MATERIAL_ID(obj.materialID);
	uint triIdx0 = (triId * 3 + 0) + startIndex;
	uint triIdx1 = (triId * 3 + 1) + startIndex;
	uint triIdx2 = (triId * 3 + 2) + startIndex;

	uint vtxIndex0 = LoadByte(Get(vtxOpaqueIndex), (triIdx0 + vertexOffset) << 2);
	uint vtxIndex1 = LoadByte(Get(vtxOpaqueIndex), (triIdx1 + vertexOffset) << 2);
	uint vtxIndex2 = LoadByte(Get(vtxOpaqueIndex), (triIdx2 + vertexOffset) << 2);
	
	// Load vertex data of the 3 vertices
	float3 v0pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex0 * 12)).xyz;
	float3 v1pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex1 * 12)).xyz;
	float3 v2pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex2 * 12)).xyz;

  float4x4 vp = mul(info.projMat, info.viewMat);
	float4x4 mvp = mul(vp, obj.modelMat);

	float4 clipPos0 = mul(mvp, float4(v0pos, 1.0f));
	float4 clipPos1 = mul(mvp, float4(v1pos, 1.0f));
	float4 clipPos2 = mul(mvp, float4(v2pos, 1.0f));

	RETURN(float4(0,0,0,0));
}

