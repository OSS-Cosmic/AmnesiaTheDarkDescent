#include "scene_resource.h.fsl"
#include "packing.h.fsl"
#include "visiblity_defs.h.fsl"
#include "visibility_utility.h.fsl"
#include "math_utils.h.fsl"
#include "parallax_bindless.h.fsl"

STRUCT(PsIn)
{
    DATA(float4, position,  SV_Position);
    DATA(float2, screenPos, TEXCOORD0);
};


float4 PS_MAIN(PsIn In)
{
  INIT_MAIN;
    
  const float4 visRaw = LoadTex2D(Get(visibilityTexture), Get(nearEdgeClampSampler), uint2(In.position.xy), 0);
  const uint objectId_triId = packUnorm4x8(visRaw);
  const uint objectId = SCENE_VIZ_OBJECT_ID(objectId_triId);
  const uint triId = SCENE_VIZ_PRIM_ID(objectId_triId);

  if(objectId_triId == ~0u) {
      discard;
  }

  UniformObject obj = Get(sceneObjects)[objectId];
  uint startIndex = obj.indexOffset;
  uint vertexOffset = obj.vertexOffset;
  ViewportInfo viewInfo = Get(viewport);
    
  float4x4 vp = mul(viewInfo.projMat, viewInfo.viewMat);
  float4x4 mvp = mul(vp, obj.modelMat);
  float3x3 normalMat = ToNormalMat(obj.invModelMat, viewInfo.invViewMat);

  uint triIdx0 = (triId * 3 + 0) + startIndex;
  uint triIdx1 = (triId * 3 + 1) + startIndex;
  uint triIdx2 = (triId * 3 + 2) + startIndex;

  uint vtxIndex0 = LoadByte(Get(vtxOpaqueIndex), triIdx0 << 2) + vertexOffset;
  uint vtxIndex1 = LoadByte(Get(vtxOpaqueIndex), triIdx1 << 2) + vertexOffset;
  uint vtxIndex2 = LoadByte(Get(vtxOpaqueIndex), triIdx2 << 2) + vertexOffset;

  // Load vertex data of the 3 vertices
  float3 v0pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex0 * 12)).xyz;
  float3 v1pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex1 * 12)).xyz;
  float3 v2pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex2 * 12)).xyz;

  float2 twoOverWindowSize = 1.5 / viewInfo.rect.zw; 
  const float4 clipPos0 = mul(mvp, float4(v0pos, 1.0f));
  const float4 clipPos1 = mul(mvp, float4(v1pos, 1.0f));
  const float4 clipPos2 = mul(mvp, float4(v2pos, 1.0f));
  BarycentricDeriv derivativesOut = CalcFullBary(clipPos0, clipPos1, clipPos2, In.screenPos, twoOverWindowSize);
  // TEXTURE COORD INTERPOLATION
  GradientInterpolationResults results = Interpolate2DWithDeriv(derivativesOut, make_f3x2_cols(
          asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex0 * 8)).xy, // LoadByte2 is not avaliable 
          asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex1 * 8)).xy,
          asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex2 * 8)).xy 
  ));
  
  float3 normal = InterpolateWithDeriv_float3x3(derivativesOut, make_f3x3_rows(
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex0 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex1 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex2 * 12))
  ));

  float3 tangent = InterpolateWithDeriv_float3x3(derivativesOut, make_f3x3_rows(
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex0 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex1 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex2 * 12))
  ));
  float3 worldTangent = normalize(mul(normalMat, tangent.xyz));
  float3 worldBitangent = normalize(mul(normalMat, cross(tangent, normal)));
  float3 worldNormal = normalize(mul(normalMat, normal.xyz));

  // Interpolate the 1/w (one_over_w) for all three vertices of the triangle using the barycentric coordinates and the delta vector
  const float w = dot(float3(clipPos0.w, clipPos1.w, clipPos2.w), derivativesOut.m_lambda);

  // Reconstruct the Z value at this screen point performing only the necessary matrix * vector multiplication operations that involve computing Z
  const float z = ((w * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear)) - ((2.0 * viewInfo.zNear * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear));
  
  // Calculate the world position coordinates:
  // First the projected coordinates at this point are calculated using In.screenPos and the computed Z value at this point.
  // Then, multiplying the perspective projected coordinates by the inverse view-projection matrix (invVP) produces world coordinates
  const float3 position = mul(viewInfo.invViewProj, float4(In.screenPos * w, z, w)).xyz;
  const float3 viewPosition = mul(viewInfo.viewMat, float4(position, 1.0)).xyz;

  float linearZ = depthLinearization(z/w, viewInfo.zNear, viewInfo.zFar);
  float mip = pow(pow(linearZ, 0.9f) * 5.0f, 1.5f);
  
  float2 texCoordDX = results.dx * mip;
  float2 texCoordDY = results.dy * mip;

  uint materialIndex = obj.materialIndex;
  DiffuseMaterial material = Get(sceneDiffuseMat)[materialIndex];  

  float2 texCoord = results.interp;
  float4 diffuseColor = LoadTex2D(Get(albedoTexture), Get(nearEdgeClampSampler), uint2(In.position.xy), 0);
  
  if(isTextureIndexValid(material.heightTextureIndex)) {
      texCoord += ParallaxAdvance(
          results.interp, 
          0.0,
          32.0, 
          material.heightMapScale * PARALLAX_MULTIPLIER,
          viewPosition.xyz,
          worldNormal,
          worldTangent,
          worldBitangent,
          material.heightTextureIndex,
          (material.config & MATERIAL_IS_HEIGHT_SINGLE_CHANNEL) > 0);
  }
  float4 normalSample = float4(0,0,0,0);
  float3 shadedColor = float3(0.0,0.0,0.0);  

  if (SampleSceneTextureGradFloat4(material.normalTextureIndex, Get(sceneSampler), texCoord, texCoordDX, texCoordDY, normalSample)) {
      normalSample -=  0.5;
      worldNormal = normalize(normalSample.x * worldTangent + normalSample.y * worldBitangent+ normalSample.z * worldNormal);
  } 
  float4 illuminationSample = float4(0,0,0,0);
  if(obj.illuminationAmount > 0 && SampleSceneTextureGradFloat4(material.illuminiationTextureIndex, Get(sceneSampler), texCoord, texCoordDX, texCoordDY, illuminationSample)) {
     shadedColor += (obj.illuminationAmount * illuminationSample.xyz); 
  }

  float2 texelPos = (In.position.xy / viewInfo.rect.zw);
  const uint2 clusterCoords = uint2(floor(texelPos * float2(LIGHT_CLUSTER_WIDTH, LIGHT_CLUSTER_HEIGHT)));
  const uint slice = calcDepthSlice(float(LIGHT_CLUSTER_SLICE), z, viewInfo.zNear, viewInfo.zFar);
  
  const uint lightClusterCount = LoadByte(Get(lightClustersCount), LIGHT_FROXEL_COUNT_POS(clusterCoords.x, clusterCoords.y, slice) << 2);
  float4 specular = float4(0,0,0,0);	
  SampleSceneTextureGradFloat4(material.specularTextureIndex, Get(sceneSampler), texCoord, texCoordDX, texCoordDY, specular);
  for(uint j = 0; j < lightClusterCount; ++j) {
      const uint index = LoadByte(Get(lightClusters), LIGHT_FROXEL_DATA_POS(clusterCoords.x, clusterCoords.y, slice, j) << 2);
      const Light light = Get(lights)[index];
            
      float4 lightCameraSpace = mul(viewInfo.viewMat, float4(light.position.xyz, 1.0f));
      
      const float3 lightDir = (lightCameraSpace.xyz  - viewPosition) * (1.0 / light.radius);
      const float3 normalLightDir = normalize(lightDir);
      const float fLDotN = max(dot(worldNormal, normalLightDir), 0.0);
      
      const float3 lightDiffuseColor = light.color.xyz * fLDotN;
      const float3 halfVec = normalize(normalLightDir + normalize(-viewPosition.xyz));
      const float specIntensity = specular.x;
      const float specPower = exp2(specular.y * 10.0) + 1.0;
      const float specularValue = light.color.w * specIntensity *  pow( clamp( dot( halfVec, worldNormal), 0.0, 1.0), specPower );
      
      switch(light.lightType) {
        case LIGHT_TYPE_SPOT_LIGHT: {
            const float3 lightCameraDirection = -mul(to_f3x3(viewInfo.viewMat), light.direction);
            float attenuation = saturate(1.0f - dot(lightDir , lightDir));
            if(acos(dot(normalLightDir, lightCameraDirection)) > light.angle) {
              break;
            }
            float4 projectionUV = mul(light.viewProjection, float4(position.xyz,1.0));
            projectionUV.xyz = (projectionUV.xyz / projectionUV.w);
            projectionUV.xy = projectionUV.xy * 0.5 + 0.5;
            projectionUV.w = 1.0;

            float4 shadowSample;
            if(SampleSceneTextureProjFloat4(light.goboTextureIndex, Get(nearEdgeClampSampler), projectionUV, shadowSample)) {
              attenuation *= shadowSample.x; 
            } else {
              float oneMinusCos = 1.0 - dot(normalLightDir, lightCameraDirection);
              attenuation *= saturate(1.0 - (oneMinusCos / (1.0 - cos(light.angle * 0.5))));
            }

	        const float depthBias = 0.0005;
	        if(light.normalizeShadow.z != 0.0 && light.normalizeShadow.w != 0.0) {
               float2 sampleOffset = (projectionUV.xy * light.normalizeShadow.zw);
               float2 pos = light.normalizeShadow.xy + float2(sampleOffset.x, light.normalizeShadow.w - sampleOffset.y);
              attenuation *= CompareTex2DProj(Get(shadowTexture), Get(shadowCmpSampler), float4(pos.xy, projectionUV.z - depthBias, projectionUV.w));
            }
            shadedColor += ((specularValue.xxx * light.color.xyz) + (diffuseColor.xyz * light.color.xyz * fLDotN)) * attenuation;
          break;
        }
        default: {
          const float attenuation = saturate(1.0f - dot(lightDir , lightDir)) * max(dot(worldNormal, normalLightDir), 0.0f);
          shadedColor += (specularValue.xxx + diffuseColor.xyz ) * light.color.xyz * attenuation;
          break;
        }
      }
  }

  //Out.outColor = float4(diffuseColor.rgb, 0.0f); 
  //Out.test = float4(clusterCoords.x,clusterCoords.y,slice, lightClusterCount);
  RETURN(float4(shadedColor, 0.0));
}


