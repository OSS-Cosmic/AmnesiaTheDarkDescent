#include "scene_resource.h.fsl"
#include "math_utils.h.fsl"
#include "visiblity_defs.h.fsl"
#include "visibility_utility.h.fsl"
#include "parallax_bindless.h.fsl"

float random(float3 seed, float3 freq)
{
	// project seed on random constant vector
	float dt = dot(floor(seed * freq), float3(53.1215f, 21.1352f, 9.1322f));
	// return only the fractional part
	return frac(sin(dt) * 2105.2354f);
}

#define NUM_SHADOW_SAMPLES 32 
STATIC const float shadowSamples[NUM_SHADOW_SAMPLES * 2] =
{
	-0.17466460f, -0.7913184f,
	-0.12979200f, -0.4477116f,
	 0.08863912f, -0.898169f,
	-0.58914990f, -0.6781639f,
	 0.17484090f, -0.5252063f,
	 0.64833250f, -0.752117f,
	 0.45293190f, -0.384986f,
	 0.09757467f, -0.1166954f,
	 0.38576580f, -0.9096935f,
	 0.56130580f, -0.1283066f,
	 0.76801100f, -0.4906538f,
	 0.84994380f, -0.220937f,
	 0.69465550f,  0.1605866f,
	 0.96142970f,  0.05975229f,
	 0.79865440f,  0.5325912f,
	 0.45139650f,  0.5592551f,
	 0.28476930f,  0.2293397f,
	-0.21189960f, -0.1609127f,
	-0.43578930f, -0.3808875f,
	-0.46626720f, -0.05288446f,
	-0.13912900f,  0.2394065f,
	 0.17818530f,  0.5254948f,
	 0.42878540f,  0.899425f,
	 0.12893490f,  0.8724155f,
	-0.69243230f, -0.2203967f,
	-0.48997000f,  0.2795907f,
	-0.26117240f,  0.7359962f,
	-0.77041720f,  0.4233134f,
	-0.85010400f,  0.1263935f,
	-0.83452670f, -0.4991361f,
	-0.53809670f,  0.6264234f,
	-0.97693120f, -0.1550569f
};
STATIC const float NUM_SHADOW_SAMPLES_INV = (1.0f / NUM_SHADOW_SAMPLES);

float PCF(float4 projectionUV) {
	// waste of shader cycles
	// Perform percentage-closer shadows with randomly rotated poisson kernel
	float shadowFactor = 0.0f;

	float shadowFilterSize = 0.0004f;
	float angle = random(projectionUV.xyz, f3(20.0f));
	float s = sin(angle);
	float c = cos(angle);

	for (uint i = 0; i < NUM_SHADOW_SAMPLES; i++)
	{
        float2 offset = float2(shadowSamples[i * 2], shadowSamples[i * 2 + 1]);
        offset = float2(offset.x * c + offset.y * s, offset.x * -s + offset.y * c);
        offset *= shadowFilterSize;
			
     shadowFactor += CompareTex2DProj(Get(shadowTexture), Get(shadowCmpSampler), float4(projectionUV.xy + offset, projectionUV.zw));
	}
	shadowFactor *= NUM_SHADOW_SAMPLES_INV;
	return shadowFactor;
}



STRUCT(PsIn)
{
    DATA(float4, position,  SV_Position);
    DATA(float2, screenPos, TEXCOORD0);
};


float4 PS_MAIN(PsIn In)
{
  INIT_MAIN;
    
  const float4 visRaw = LoadTex2D(Get(visibilityTexture), Get(nearEdgeClampSampler), uint2(In.position.xy), 0);
  const uint objectId_triId = packUnorm4x8(visRaw);
  const uint objectId = SCENE_VIZ_OBJECT_ID(objectId_triId);
  const uint triId = SCENE_VIZ_PRIM_ID(objectId_triId);

  if(objectId_triId == ~0u) {
      discard;
  }

  UniformObject obj = Get(sceneObjects)[objectId];
  uint startIndex = obj.indexOffset;
  uint vertexOffset = obj.vertexOffset;
  ViewportInfo viewInfo = Get(viewport);
    
  float4x4 vp = mul(viewInfo.projMat, viewInfo.viewMat);
  float4x4 mvp = mul(vp, obj.modelMat);
  float3x3 normalMat = ToNormalMat(obj.invModelMat, viewInfo.invViewMat);

  uint triIdx0 = (triId * 3 + 0) + startIndex;
  uint triIdx1 = (triId * 3 + 1) + startIndex;
  uint triIdx2 = (triId * 3 + 2) + startIndex;

  uint vtxIndex0 = LoadByte(Get(vtxOpaqueIndex), triIdx0 << 2) + vertexOffset;
  uint vtxIndex1 = LoadByte(Get(vtxOpaqueIndex), triIdx1 << 2) + vertexOffset;
  uint vtxIndex2 = LoadByte(Get(vtxOpaqueIndex), triIdx2 << 2) + vertexOffset;

  // Load vertex data of the 3 vertices
  float3 v0pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex0 * 12)).xyz;
  float3 v1pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex1 * 12)).xyz;
  float3 v2pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex2 * 12)).xyz;

  float2 twoOverWindowSize = 1.5 / viewInfo.rect.zw; 
  const float4 clipPos0 = mul(mvp, float4(v0pos, 1.0f));
  const float4 clipPos1 = mul(mvp, float4(v1pos, 1.0f));
  const float4 clipPos2 = mul(mvp, float4(v2pos, 1.0f));
  BarycentricDeriv derivativesOut = CalcFullBary(clipPos0, clipPos1, clipPos2, In.screenPos, twoOverWindowSize);
  // TEXTURE COORD INTERPOLATION
  GradientInterpolationResults results = Interpolate2DWithDeriv(derivativesOut, make_f3x2_cols(
    asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex0 * 8)).xy, // LoadByte2 is not avaliable 
    asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex1 * 8)).xy,
    asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex2 * 8)).xy 
  ));
  
  float3 normal = InterpolateWithDeriv_float3x3(derivativesOut, make_f3x3_rows(
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex0 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex1 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex2 * 12))
  ));

  float3 tangent = InterpolateWithDeriv_float3x3(derivativesOut, make_f3x3_rows(
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex0 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex1 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex2 * 12))
  ));
  float3 worldTangent = normalize(mul(normalMat, tangent.xyz));
  float3 worldBitangent = normalize(mul(normalMat, cross(tangent, normal)));
  float3 worldNormal = normalize(mul(normalMat, normal.xyz));

  // Interpolate the 1/w (one_over_w) for all three vertices of the triangle using the barycentric coordinates and the delta vector
  const float w = dot(float3(clipPos0.w, clipPos1.w, clipPos2.w), derivativesOut.m_lambda);

  // Reconstruct the Z value at this screen point performing only the necessary matrix * vector multiplication operations that involve computing Z
  //const float z = ((w * (viewInfo.zFar + viewInfo.zNear)) / (viewInfo.zFar - viewInfo.zNear)) - ((2.0 * viewInfo.zNear * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear));
  const float z = -w * getElem(viewInfo.projMat, 2, 2) + getElem(viewInfo.projMat, 3, 2);

  // Calculate the world position coordinates:
  // First the projected coordinates at this point are calculated using In.screenPos and the computed Z value at this point.
  // Then, multiplying the perspective projected coordinates by the inverse view-projection matrix (invVP) produces world coordinates
  const float3 position = mul(viewInfo.invViewProj, float4(In.screenPos * w, z, w)).xyz;
  const float3 viewPosition = mul(viewInfo.viewMat, float4(position, 1.0)).xyz;

  float linearZ = depthLinearization(z/w, viewInfo.zNear, viewInfo.zFar);
  float mip = pow(pow(linearZ, 0.9f) * 5.0f, 1.5f);
  
  float2 texCoordDX = results.dx * mip;
  float2 texCoordDY = results.dy * mip;

  uint materialIndex = obj.materialIndex;
  DiffuseMaterial material = Get(sceneDiffuseMat)[materialIndex];  

  float2 texCoord = results.interp;
  float4 diffuseColor = LoadTex2D(Get(albedoTexture), Get(nearEdgeClampSampler), uint2(In.position.xy), 0);
  
  if(isTextureIndexValid(material.heightTextureIndex)) {
      texCoord += ParallaxAdvance(
          results.interp, 
          0.0,
          32.0, 
          material.heightMapScale * PARALLAX_MULTIPLIER,
          viewPosition.xyz,
          worldNormal,
          worldTangent,
          worldBitangent,
          material.heightTextureIndex,
          (material.config & MATERIAL_IS_HEIGHT_SINGLE_CHANNEL) > 0);
  }
  float4 normalSample = float4(0,0,0,0);
  float3 shadedColor = float3(0.0,0.0,0.0);  

  const uint normalTextureIndex = material.normalTextureIndex;
  if (isTextureIndexValid(normalTextureIndex)) {
      BeginNonUniformResourceIndex(normalTextureIndex);
	      normalSample = SampleGradTex2D(Get(sceneTextures)[normalTextureIndex], Get(sceneSampler), texCoord, texCoordDX, texCoordDY);
      EndNonUniformResourceIndex(); 
      
      normalSample -=  0.5;
      worldNormal = normalize(normalSample.x * worldTangent + normalSample.y * worldBitangent+ normalSample.z * worldNormal);
  } 
  const uint illuminationTextureIndex = material.illuminationTextureIndex;
  if(obj.illuminationAmount > 0 && isTextureIndexValid(illuminationTextureIndex) ) {
      BeginNonUniformResourceIndex(illuminationTextureIndex);
	      shadedColor += obj.illuminationAmount * SampleGradTex2D(Get(sceneTextures)[illuminationTextureIndex], Get(sceneSampler), texCoord, texCoordDX, texCoordDY).xyz;
      EndNonUniformResourceIndex(); 
  }

  float2 texelPos = (In.position.xy / viewInfo.rect.zw);
  const uint2 clusterCoords = uint2(floor(texelPos * float2(LIGHT_CLUSTER_WIDTH, LIGHT_CLUSTER_HEIGHT)));
  const uint slice = calcDepthSlice(float(LIGHT_CLUSTER_SLICE), z, viewInfo.zNear, viewInfo.zFar);
  
  const uint lightClusterCount = LoadByte(Get(lightClustersCount), LIGHT_FROXEL_COUNT_POS(clusterCoords.x, clusterCoords.y, slice) << 2);
  float4 specular = float4(0,0,0,0);	
  const uint specularTextureIndex = material.specularTextureIndex;
  if(isTextureIndexValid(specularTextureIndex)) {
    BeginNonUniformResourceIndex(specularTextureIndex);
	    specular = SampleGradTex2D(Get(sceneTextures)[specularTextureIndex], Get(sceneSampler), texCoord, texCoordDX, texCoordDY);
    EndNonUniformResourceIndex(); 
  }
  for(uint j = 0; j < lightClusterCount; ++j) {
      const uint index = LoadByte(Get(lightClusters), LIGHT_FROXEL_DATA_POS(clusterCoords.x, clusterCoords.y, slice, j) << 2);
      const Light light = Get(lights)[index];
            
      float4 lightCameraSpace = mul(viewInfo.viewMat, float4(light.position.xyz, 1.0f));
      
      const float3 lightDir = (lightCameraSpace.xyz  - viewPosition) * (1.0 / light.radius);
      const float3 normalLightDir = normalize(lightDir);
      const float fLDotN = max(dot(worldNormal, normalLightDir), 0.0);
      
      const float3 lightDiffuseColor = light.color.xyz * fLDotN;
      const float3 halfVec = normalize(normalLightDir + normalize(-viewPosition.xyz));
      const float specIntensity = specular.x;
      const float specPower = exp2(specular.y * 10.0) + 1.0;
      const float specularValue = light.color.w * specIntensity *  pow( clamp( dot( halfVec, worldNormal), 0.0, 1.0), specPower );
      
      switch(light.lightType) {
        case LIGHT_TYPE_SPOT_LIGHT: {
            const float3 lightCameraDirection = -mul(to_f3x3(viewInfo.viewMat), light.direction);
            float attenuation = saturate(1.0f - dot(lightDir , lightDir));
            if(acos(dot(normalLightDir, lightCameraDirection)) > light.angle) {
              break;
            }
            float4 projectionUV = mul(light.viewProjection, float4(position.xyz,1.0));
            projectionUV.xyz = (projectionUV.xyz / projectionUV.w);
            projectionUV.xy = projectionUV.xy * 0.5 + 0.5;
            projectionUV.w = 1.0;

            const uint goboTextureIndex = light.goboTextureIndex;
            if(isTextureIndexValid(goboTextureIndex)) {
                BeginNonUniformResourceIndex(goboTextureIndex);
                    attenuation *= SampleTex2DProj(Get(sceneTextures)[goboTextureIndex], Get(nearEdgeClampSampler), projectionUV).x;
                EndNonUniformResourceIndex(); 
            } else {
              float oneMinusCos = 1.0 - dot(normalLightDir, lightCameraDirection);
              attenuation *= saturate(1.0 - (oneMinusCos / (1.0 - cos(light.angle * 0.5))));
            }

	        const float depthBias = 0.0005;
	        if(light.normalizeShadow.z != 0.0 && light.normalizeShadow.w != 0.0) {
               float2 sampleOffset = (projectionUV.xy * light.normalizeShadow.zw);
               float2 pos = light.normalizeShadow.xy + float2(sampleOffset.x, light.normalizeShadow.w - sampleOffset.y);
               attenuation *= PCF(float4(pos.xy, projectionUV.z - depthBias, projectionUV.w));
            }
            shadedColor += ((specularValue.xxx * light.color.xyz) + (diffuseColor.xyz * light.color.xyz * fLDotN)) * attenuation;
          break;
        }
        default: {
          const float attenuation = saturate(1.0f - dot(lightDir , lightDir)) * max(dot(worldNormal, normalLightDir), 0.0f);
          shadedColor += (specularValue.xxx + diffuseColor.xyz ) * light.color.xyz * attenuation;
          break;
        }
      }
  }

  RETURN(float4(shadedColor, 0.0));
}


