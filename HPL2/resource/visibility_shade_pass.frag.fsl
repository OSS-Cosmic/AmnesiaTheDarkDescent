#include "scene_resource.h.fsl"
#include "packing.h.fsl"
#include "visiblity_defs.h.fsl"
#include "visibility_utility.h.fsl"
#include "math_utils.h.fsl"
#include "parallax_bindless.h.fsl"

STRUCT(PsIn)
{
	DATA(float4, position,  SV_Position);
	DATA(float2, screenPos, TEXCOORD0);
};

STRUCT(PsOut)
{
    DATA(float4, outColor , SV_Target0);
    DATA(float4, test, SV_Target1);
};

PsOut PS_MAIN(PsIn In)
{
	INIT_MAIN;
	
	float4 visRaw = LoadTex2D(Get(visibilityTexture), Get(nearEdgeClampSampler), uint2(In.position.xy), 0);
	// Unpack float4 render target data into uint to extract data
	uint objectId_triId = packUnorm4x8(visRaw);
	uint objectId = SCENE_VIZ_OBJECT_ID(objectId_triId);
	uint triId = SCENE_VIZ_PRIM_ID(objectId_triId);

	if(objectId_triId == ~0u) {
		discard;
	}

	UniformObject obj = Get(sceneObjects)[objectId];
	uint startIndex = Get(indirectDrawArgs)[obj.indirectDrawOffset + INDIRECT_DRAW_ARGUMENTS_START_INDEX_OFFSET];
	uint vertexOffset = Get(indirectDrawArgs)[obj.indirectDrawOffset + INDIRECT_DRAW_ARGUMENTS_VERTEX_OFFSET_OFFSET];
  ViewportInfo viewInfo = Get(viewports)[PRIMARY_VIEWPORT_INDEX];
	
  float4x4 vp = mul(viewInfo.projMat, viewInfo.viewMat);
	float4x4 mvp = mul(vp, obj.modelMat);
	float4x4 mv = mul(viewInfo.viewMat, obj.modelMat);
  float3x3 normalMat = ToNormalMat(obj.invModelMat, viewInfo.invViewMat);

	//uint materialID = MATERIAL_ID(obj.materialID);
	uint triIdx0 = (triId * 3 + 0) + startIndex;
	uint triIdx1 = (triId * 3 + 1) + startIndex;
	uint triIdx2 = (triId * 3 + 2) + startIndex;

	uint vtxIndex0 = LoadByte(Get(vtxOpaqueIndex), triIdx0 << 2) + vertexOffset;
	uint vtxIndex1 = LoadByte(Get(vtxOpaqueIndex), triIdx1 << 2) + vertexOffset;
	uint vtxIndex2 = LoadByte(Get(vtxOpaqueIndex), triIdx2 << 2) + vertexOffset;

	// Load vertex data of the 3 vertices
	float3 v0pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex0 * 12)).xyz;
	float3 v1pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex1 * 12)).xyz;
	float3 v2pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex2 * 12)).xyz;

	// TEXTURE COORD INTERPOLATION
	f3x2 texCoords = make_f3x2_cols(
			asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex0 * 8)).xy, // LoadByte2 is not avaliable 
			asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex1 * 8)).xy,
			asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex2 * 8)).xy 
	);
	
	f3x3 normals = make_f3x3_rows(
		asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex0 * 12)),
		asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex1 * 12)),
		asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex2 * 12))
	);

	f3x3 tangents = make_f3x3_rows(
		asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex0 * 12)),
		asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex1 * 12)),
		asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex2 * 12))
	);

	float4 clipPos0 = mul(mvp, float4(v0pos, 1.0f));
	float4 clipPos1 = mul(mvp, float4(v1pos, 1.0f));
	float4 clipPos2 = mul(mvp, float4(v2pos, 1.0f));


	float2 twoOverWindowSize = 2.0 / viewInfo.rect.zw; 
	BarycentricDeriv derivativesOut = CalcFullBary(clipPos0, clipPos1, clipPos2, In.screenPos, twoOverWindowSize);
	// Interpolate the 1/w (one_over_w) for all three vertices of the triangle using the barycentric coordinates and the delta vector
	float w = dot(float3(clipPos0.w, clipPos1.w, clipPos2.w), derivativesOut.m_lambda);

	// Reconstruct the Z value at this screen point performing only the necessary matrix * vector multiplication operations that involve computing Z
	float z = ((w * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear)) - ((2.0 * viewInfo.zNear * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear));
	//float z = w * getElem(viewInfo.projMat, 2, 2) + getElem(viewInfo.projMat, 3, 2);

	// Calculate the world position coordinates:
	// First the projected coordinates at this point are calculated using In.screenPos and the computed Z value at this point.
	// Then, multiplying the perspective projected coordinates by the inverse view-projection matrix (invVP) produces world coordinates
	float3 position = mul(viewInfo.invViewProj, float4(In.screenPos * w, z, w)).xyz;
	float3 viewPosition = mul(viewInfo.viewMat, float4(position, 1.0)).xyz;

	GradientInterpolationResults results = Interpolate2DWithDeriv(derivativesOut, texCoords);
	float3 normal = InterpolateWithDeriv_float3x3(derivativesOut, normals);
	float3 tangent = InterpolateWithDeriv_float3x3(derivativesOut, tangents);

	float linearZ = depthLinearization(z/w, viewInfo.zNear, viewInfo.zFar);
	float mip = pow(pow(linearZ, 0.9f) * 5.0f, 1.5f);
	
	float2 texCoordDX = results.dx * mip;
	float2 texCoordDY = results.dy * mip;
    
  float3 worldNormal = normalize(mul(normalMat, normal.xyz));
  float3 worldTangent = normalize(mul(normalMat, tangent.xyz));
  float3 worldBitangent = normalize(mul(normalMat, cross(tangent, normal)));

  uint materialIndex = MATERIAL_INDEX(obj.materialID);
  DiffuseMaterial diffuseMat = Get(sceneDiffuseMat)[materialIndex];  

	SceneTexture tex;
	tex.filterID = diffuseMat.samplerIndex; 

	SceneTexture diffuseTex = CreateGradientSceneTexture(diffuseMat.samplerIndex, DiffuseMaterial_DiffuseTexture_ID(diffuseMat), texCoordDX, texCoordDY);
	SceneTexture heightTexture = CreateGradientSceneTexture(diffuseMat.samplerIndex, DiffuseMaterial_HeightTexture_ID(diffuseMat), texCoordDX, texCoordDY);
	SceneTexture specularTex = CreateGradientSceneTexture(diffuseMat.samplerIndex, DiffuseMaterial_SpecularTexture_ID(diffuseMat), texCoordDX, texCoordDY);
  SceneTexture illuminationTex = CreateGradientSceneTexture(diffuseMat.samplerIndex, DiffuseMaterial_IlluminiationTexture_ID(diffuseMat), texCoordDX, texCoordDY);
  SceneTexture normalTex = CreateGradientSceneTexture(diffuseMat.samplerIndex,DiffuseMaterial_NormalTexture_ID(diffuseMat), texCoordDX, texCoordDY);

	float2 texCoord = results.interp;
  if(IsSceneTextureValid(heightTexture)) {
      texCoord += ParallaxAdvance(
          results.interp, 
          0.0,
          32.0, 
          diffuseMat.heightMapScale * PARALLAX_MULTIPLIER,
          viewPosition.xyz,
          worldNormal,
          worldTangent,
          worldBitangent,
          heightTexture,
          (diffuseMat.materialConfig & MATERIAL_IS_HEIGHT_SINGLE_CHANNEL) > 0);
  }
	float4 specular = float4(0,0,0,0);	
	float4 diffuseColor;
	SampleSceneTextureFloat4(diffuseTex, texCoord, diffuseColor);
	SampleSceneTextureFloat4(specularTex , texCoord, specular);


  float4 normalSample;
  if (SampleSceneTextureFloat4(normalTex, texCoord, normalSample)) {
      normalSample -=  0.5;
      worldNormal = normalize(normalSample.x * worldTangent + normalSample.y * worldBitangent+ normalSample.z * worldNormal);
  } 

  float2 texelPos = (In.position.xy / viewInfo.rect.zw);
	uint2 clusterCoords = uint2(floor(texelPos * float2(LIGHT_CLUSTER_WIDTH, LIGHT_CLUSTER_HEIGHT)));
	uint numLightsInCluster = Get(lightClustersCount)[LIGHT_CLUSTER_COUNT_POS(clusterCoords.x, clusterCoords.y)];
  float4 outputColor = float4(0.0,0,0, 0);
  for(uint j = 0; j < numLightsInCluster; j++) {
		uint lightId = Get(lightClusters)[LIGHT_CLUSTER_DATA_POS(j, clusterCoords.x, clusterCoords.y)];
    PointLight pl = Get(pointLights)[lightId];
	  float4 lightPosWorldSpace = float4(pl.lightPos.xyz, 1.0f);
	  float4 lightCameraSpace = mul(viewInfo.viewMat, lightPosWorldSpace);
      
    const float3 lightDir = (lightCameraSpace.xyz  - viewPosition) * (1.0 / pl.lightRadius);
    const float3 normalLightDir = normalize(lightDir);
	  const float attenuation = saturate(1.0f - dot(lightDir , lightDir));
    const float fLDotN = max(dot(worldNormal, normalLightDir), 0.0);
    
    float specularValue = 0.0;
    float3 lightDiffuseColor = pl.lightColor.xyz * fLDotN;
    if(pl.lightColor.w > 0.0) {
        float3 halfVec = normalize(normalLightDir + normalize(-viewPosition.xyz));
        float specIntensity = specular.x;
        float specPower = exp2(specular.y * 10.0) + 1.0;
        specularValue = pl.lightColor.w * specIntensity *  pow( clamp( dot( halfVec, worldNormal), 0.0, 1.0), specPower );
    }
    outputColor += float4(((specularValue.xxx * pl.lightColor.xyz) + (diffuseColor.xyz * pl.lightColor.xyz * fLDotN)) * attenuation, 0.0);
  }

  float4 illuminationSample = float4(0,0,0,0);
  if(obj.illuminationAmount > 0 && SampleSceneTextureFloat4(illuminationTex, texCoord, illuminationSample)) {
     outputColor += outputColor + (obj.illuminationAmount * float4(illuminationSample.xyz, 0.0)); 
  }

	PsOut Out;
	Out.outColor = outputColor; //+ float4(qt.x, qt.y,0,0)  * (numLightsInCluster /  float(LIGHT_CLUSTER_COUNT));
	//Out.test = float4(viewPosition, w);
	RETURN(Out);

}


