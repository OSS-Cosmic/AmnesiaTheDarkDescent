#include "scene_resource.h.fsl"
#include "packing.h.fsl"
#include "visiblity_defs.h.fsl"
#include "visibility_utility.h.fsl"
#include "math_utils.h.fsl"
#include "parallax_bindless.h.fsl"

STRUCT(PsIn)
{
    DATA(float4, position,  SV_Position);
    DATA(float2, screenPos, TEXCOORD0);
};

STRUCT(PsOut)
{
    DATA(float4, outColor , SV_Target0);
    DATA(float4, test, SV_Target1);
};

PsOut PS_MAIN(PsIn In)
{
  INIT_MAIN;
    
  const float4 visRaw = LoadTex2D(Get(visibilityTexture), Get(nearEdgeClampSampler), uint2(In.position.xy), 0);
  // Unpack float4 render target data into uint to extract data
  const uint objectId_triId = packUnorm4x8(visRaw);
  const uint objectId = SCENE_VIZ_OBJECT_ID(objectId_triId);
  const uint triId = SCENE_VIZ_PRIM_ID(objectId_triId);

  if(objectId_triId == ~0u) {
      discard;
  }

  UniformObject obj = Get(sceneObjects)[objectId];
  uint startIndex = obj.indexOffset;
  uint vertexOffset = obj.vertexOffset;
  ViewportInfo viewInfo = Get(viewports)[PRIMARY_VIEWPORT_INDEX];
    
  float4x4 vp = mul(viewInfo.projMat, viewInfo.viewMat);
  float4x4 mvp = mul(vp, obj.modelMat);
  float3x3 normalMat = ToNormalMat(obj.invModelMat, viewInfo.invViewMat);

  //uint materialID = MATERIAL_ID(obj.materialID);
  uint triIdx0 = (triId * 3 + 0) + startIndex;
  uint triIdx1 = (triId * 3 + 1) + startIndex;
  uint triIdx2 = (triId * 3 + 2) + startIndex;

  uint vtxIndex0 = LoadByte(Get(vtxOpaqueIndex), triIdx0 << 2) + vertexOffset;
  uint vtxIndex1 = LoadByte(Get(vtxOpaqueIndex), triIdx1 << 2) + vertexOffset;
  uint vtxIndex2 = LoadByte(Get(vtxOpaqueIndex), triIdx2 << 2) + vertexOffset;

  // Load vertex data of the 3 vertices
  float3 v0pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex0 * 12)).xyz;
  float3 v1pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex1 * 12)).xyz;
  float3 v2pos = asfloat(LoadByte4(Get(vtxOpaquePosition), vtxIndex2 * 12)).xyz;

  float2 twoOverWindowSize = 1.5 / viewInfo.rect.zw; 
  const float4 clipPos0 = mul(mvp, float4(v0pos, 1.0f));
  const float4 clipPos1 = mul(mvp, float4(v1pos, 1.0f));
  const float4 clipPos2 = mul(mvp, float4(v2pos, 1.0f));
  BarycentricDeriv derivativesOut = CalcFullBary(clipPos0, clipPos1, clipPos2, In.screenPos, twoOverWindowSize);
  // TEXTURE COORD INTERPOLATION
  GradientInterpolationResults results = Interpolate2DWithDeriv(derivativesOut, make_f3x2_cols(
          asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex0 * 8)).xy, // LoadByte2 is not avaliable 
          asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex1 * 8)).xy,
          asfloat(LoadByte4(Get(vtxOpaqueUv), vtxIndex2 * 8)).xy 
  ));
  
  float3 normal = InterpolateWithDeriv_float3x3(derivativesOut, make_f3x3_rows(
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex0 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex1 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueNormal), vtxIndex2 * 12))
  ));

  float3 tangent = InterpolateWithDeriv_float3x3(derivativesOut, make_f3x3_rows(
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex0 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex1 * 12)),
      asfloat(LoadByte3(Get(vtxOpaqueTangnet), vtxIndex2 * 12))
  ));
  float3 worldTangent = normalize(mul(normalMat, tangent.xyz));
  float3 worldBitangent = normalize(mul(normalMat, cross(tangent, normal)));
  float3 worldNormal = normalize(mul(normalMat, normal.xyz));

  // Interpolate the 1/w (one_over_w) for all three vertices of the triangle using the barycentric coordinates and the delta vector
  const float w = dot(float3(clipPos0.w, clipPos1.w, clipPos2.w), derivativesOut.m_lambda);

  // Reconstruct the Z value at this screen point performing only the necessary matrix * vector multiplication operations that involve computing Z
  const float z = ((w * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear)) - ((2.0 * viewInfo.zNear * viewInfo.zFar) / (viewInfo.zFar - viewInfo.zNear));
  //float z = w * getElem(viewInfo.projMat, 2, 2) + getElem(viewInfo.projMat, 3, 2);

  // Calculate the world position coordinates:
  // First the projected coordinates at this point are calculated using In.screenPos and the computed Z value at this point.
  // Then, multiplying the perspective projected coordinates by the inverse view-projection matrix (invVP) produces world coordinates
  const float3 position = mul(viewInfo.invViewProj, float4(In.screenPos * w, z, w)).xyz;
  const float3 viewPosition = mul(viewInfo.viewMat, float4(position, 1.0)).xyz;

  float linearZ = depthLinearization(z/w, viewInfo.zNear, viewInfo.zFar);
  float mip = pow(pow(linearZ, 0.9f) * 5.0f, 1.5f);
  
  float2 texCoordDX = results.dx * mip;
  float2 texCoordDY = results.dy * mip;

  uint materialIndex = MATERIAL_INDEX(obj.materialID);
  DiffuseMaterial diffuseMat = Get(sceneDiffuseMat)[materialIndex];  

  float2 texCoord = results.interp;
  if(isTextureIndexValid(diffuseMat.heightTextureIndex)) {
      texCoord += ParallaxAdvance(
          results.interp, 
          0.0,
          32.0, 
          diffuseMat.heightMapScale * PARALLAX_MULTIPLIER,
          viewPosition.xyz,
          worldNormal,
          worldTangent,
          worldBitangent,
          diffuseMat.heightTextureIndex,
          Get(sceneFilters)[diffuseMat.samplerIndex],
          (diffuseMat.materialConfig & MATERIAL_IS_HEIGHT_SINGLE_CHANNEL) > 0);
  }
  float4 diffuseColor = float4(0,0,0,0);
  float4 normalSample = float4(0,0,0,0);
	float3 shadedColor = f3(0.0f);
  SampleSceneTextureGradFloat4(diffuseMat.diffuseTextureIndex, Get(sceneFilters)[diffuseMat.samplerIndex], texCoord, texCoordDX, texCoordDY, diffuseColor);
  if (SampleSceneTextureGradFloat4(diffuseMat.normalTextureIndex, Get(sceneFilters)[diffuseMat.samplerIndex], texCoord, texCoordDX, texCoordDY, normalSample)) {
      normalSample -=  0.5;
      worldNormal = normalize(normalSample.x * worldTangent + normalSample.y * worldBitangent+ normalSample.z * worldNormal);
  } 
  float4 illuminationSample = float4(0,0,0,0);
  if(obj.illuminationAmount > 0 && SampleSceneTextureGradFloat4(diffuseMat.illuminiationTextureIndex, Get(sceneFilters)[diffuseMat.samplerIndex], texCoord, texCoordDX, texCoordDY, illuminationSample)) {
     shadedColor += (obj.illuminationAmount * illuminationSample.xyz); 
  }

  float2 texelPos = (In.position.xy / viewInfo.rect.zw);
  const uint2 clusterCoords = uint2(floor(texelPos * float2(LIGHT_CLUSTER_WIDTH, LIGHT_CLUSTER_HEIGHT)));
  const uint slice = calcDepthSlice(float(LIGHT_CLUSTER_SLICE), z, viewInfo.zNear, viewInfo.zFar);
  const uint numLightsInCluster = Get(lightClustersCount)[LIGHT_FROXEL_COUNT_POS(clusterCoords.x, clusterCoords.y, slice)];
  float4 specular = float4(0,0,0,0);	
  SampleSceneTextureGradFloat4(diffuseMat.specularTextureIndex, Get(sceneFilters)[diffuseMat.samplerIndex], texCoord, texCoordDX, texCoordDY, specular);
  for(uint j = 0; j < numLightsInCluster; ++j) {
    uint index = LoadByte(Get(lightClusters),LIGHT_FROXEL_DATA_POS(clusterCoords.x, clusterCoords.y, slice, j) << 2);
    const PointLight pl = Get(pointLights)[index];
    const float4 lightCameraSpace = mul(viewInfo.viewMat, float4(pl.lightPos.xyz, 1.0f));
    const float3 lightDir = (lightCameraSpace.xyz  - viewPosition) * (1.0f / pl.lightRadius);
    const float3 normalLightDir = normalize(lightDir);
    float attenuation = saturate(1.0f - dot(lightDir , lightDir)) * max(dot(worldNormal, normalLightDir), 0.0f);
    
    const float3 halfVec = normalize(normalLightDir + normalize(-viewPosition.xyz));
    const float specIntensity = specular.x;
    const float specPower = exp2(specular.y * 10.0f) + 1.0f;
    const float specularValue = pl.lightColor.w * specIntensity *  pow( clamp( dot( halfVec, worldNormal), 0.0f, 1.0f), specPower );
    shadedColor += (specularValue.xxx + diffuseColor.xyz ) * pl.lightColor.xyz * attenuation;
  }


  PsOut Out;
  Out.outColor = float4(shadedColor, 0.0f); //+ float4(qt.x, qt.y,0,0)  * (numLightsInCluster /  float(LIGHT_CLUSTER_COUNT));
  Out.test = float4(clusterCoords.x,clusterCoords.y,slice, z);
  RETURN(Out);

}


