#include "scene_resource.h.fsl"
#include "math_utils.h.fsl"

#ifndef _PARALLAX_BINDLESS_H
#define _PARALLAX_BINDLESS_H

float GetNormalizedDepth(SceneTexture heightMap,float startDepth, float stopDepth, float inverseDepthRange, float2 uv, bool isHeightMapSingleChannel) {
    float currentSample = 0.0;
    float4 value;
    if(SampleSceneTextureFloat4(heightMap, uv, value)) {
      if(isHeightMapSingleChannel) {
        currentSample = value.r;
      } else {
        currentSample = value.a;
      }
    }

    float normalizedDepth = 0.0;
    if(stopDepth - startDepth > 0.0001)
    {
        float minNormalizedDepth = -startDepth * inverseDepthRange;
        normalizedDepth = max(currentSample, minNormalizedDepth);
    }
    return normalizedDepth; 
}

float2 ParallaxAdvance(float2 uv,
    float depthOffset, 
    float numberOfSteps, 
    float heightMapScale, 
    float3 dir, 
    float3 normal,
    float3 tangent,
    float3 bitangent,
    SceneTexture heightMap,
    bool isHeightMapSingleChannel) {

    float3 dirToCameraTS = normalize(WorldSpaceToTangent(dir, normal, tangent, bitangent));
    
    float dirToCameraZInverse = 1.0 / dirToCameraTS.z;
    float step =  float(1.0 / numberOfSteps);
    float currentStep = 0.0;

    // the amount to shift per step, shift in the inverse direction of dirToCameraTS
    float3 delta = -dirToCameraTS.xyz * heightMapScale * dirToCameraZInverse * step;

    float depthSearchStart = depthOffset;
    float depthSearchEnd = depthSearchStart + heightMapScale;
    float inverseDepthFactor = 1.0 / heightMapScale;
    
    // This is the relative position at which we begin searching for intersection.
    // It is adjusted according to the depthOffset, raising or lowering the whole surface by depthOffset units.
    float3 parallaxOffset = -dirToCameraTS.xyz * dirToCameraZInverse * depthOffset;
   
    float currentSample;
    float4 value;
    if(SampleSceneTextureFloat4(heightMap, uv.xy + parallaxOffset.xy, value)) {
      if(isHeightMapSingleChannel) {
        currentSample = value.r;
      } else {
        currentSample = value.a;
      }
    }
    float prevSample;

    // Do a basic search for the intersect step
    while(currentSample > currentStep) {
        currentStep += step;
        parallaxOffset += delta;
                
        prevSample = currentSample;
        currentSample = GetNormalizedDepth(heightMap, depthSearchStart, depthSearchEnd, inverseDepthFactor, uv.xy + parallaxOffset.xy, isHeightMapSingleChannel);
    }

    if(currentStep > 0.0)
    {
        // Contact refinement propose by Andrea Riccardi 
        // https://www.artstation.com/andreariccardi/blog/3VPo/a-new-approach-for-parallax-mapping-presenting-the-contact-refinement-parallax-mapping-technique

        // Based on the rough approximation, rolling back to the previous step along the ray.
        parallaxOffset -= delta;
        currentStep -= step;
        currentSample = prevSample;

        // Adjust precision
        float3 adjustedDelta = delta * step;
        float adjustedStep = step * step;

        // Uses another loop with the same step numbers, this times only covers the distance between previous point and the rough intersection point.
        while(currentSample > currentStep)
        {
            currentStep += adjustedStep;
            parallaxOffset += adjustedDelta;
            prevSample = currentSample;

            currentSample = GetNormalizedDepth(heightMap, depthSearchStart, depthSearchEnd, inverseDepthFactor, uv.xy + parallaxOffset.xy, isHeightMapSingleChannel);
        }
    }
    if(parallaxOffset.z > 0.0)
    {
        parallaxOffset = float3(0,0,0);
    }
    return parallaxOffset.xy; 
}

#endif
