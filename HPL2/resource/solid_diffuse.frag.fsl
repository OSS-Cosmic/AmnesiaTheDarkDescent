#define MATERIAL_SOLID 1
#include "deferred_resources.h.fsl"
#include "deferred_common.h.fsl"

STRUCT(PsIn) 
{
    DATA(float4, Position, SV_Position);
    DATA(float3, pos, POSITION);
    DATA(float2, uv, TEXCOORD0);
    DATA(float3, view, TEXCOORD1);
    DATA(float3, normal, NORMAL);
    DATA(float3, tangent, TANGENT);
    DATA(float3, bitangent, BITANGENT);
};

STRUCT(PsOut)
{
    DATA(float4, diffuse, SV_Target0);
    DATA(float4, normal, SV_Target1);
    DATA(float4, position, SV_Target2);
    DATA(float2, specular, SV_Target3);
};

PsOut PS_MAIN(PsIn In)
{
    INIT_MAIN;
    PsOut Out;
    uint materialID = Get(uniformObjectBuffer)[Get(objectId)].materialID;

    float2 texCoord = In.uv.xy;
    float3 cameraEyeSpace = normalize(In.pos).xyz;

#ifdef PARALLAX_ENABLED
    if(HasHeight(Get(uniformMaterialBuffer)[materialID].materialConfig)) {
        float depthScale = (Get(uniformMaterialBuffer)[materialID].heightMapScale) * PARALAX_MULTIPLIER;
        float2 uv = texCoord;
        const bool isSingleChannel = IsHeightMapSingleChannel(Get(uniformMaterialBuffer)[materialID].materialConfig);
        const float numberOfSteps = 32.0;

        float3 dirToCameraTS = normalize(WorldSpaceToTangent(In.pos, In.normal, In.tangent, In.bitangent));
        
        float dirToCameraZInverse = 1.0 / dirToCameraTS.z;
        float step =  float(1.0 / numberOfSteps);
        float currentStep = 0.0;

        // the amount to shift per step, shift in the inverse direction of dirToCameraTS
        float3 delta = -dirToCameraTS.xyz * depthScale * dirToCameraZInverse * step;

        // This is the relative position at which we begin searching for intersection.
        // It is adjusted according to the depthOffset, raising or lowering the whole surface by depthOffset units.
        float3 parallaxOffset = -dirToCameraTS.xyz * dirToCameraZInverse * 0.0;
        
        float currentSample  = isSingleChannel ? 
            SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).r: 
            SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).a; 
        float prevSample;

        // Do a basic search for the intersect step
        while(currentSample > currentStep)
        {
            currentStep += step;
            parallaxOffset += delta;
                    
            prevSample = currentSample;
            currentSample = isSingleChannel ? 
                SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).r: 
                SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).a; 
        }

       // if(currentStep > 0.0)
       // {
       //     // Refining the parallax-offsetted uv, by binary searching around the naive intersection point
       //     float depthSign = 1;
       //     float3 reliefDelta = delta;
       //     float reliefStep = step;

       //     for(int i = 0; i < numberOfSteps; i++)
       //     {
       //         reliefDelta *= 0.5;
       //         reliefStep *= 0.5;
       //         depthSign = float(sign(currentSample - currentStep));

       //         parallaxOffset += reliefDelta * depthSign;
       //         currentStep += reliefStep * depthSign;

       //         currentSample = isSingleChannel ? 
       //             SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).r: 
       //             SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).a; 
       //     }
       // }
        if(currentStep > 0.0)
        {
            // Contact refinement propose by Andrea Riccardi 
            // https://www.artstation.com/andreariccardi/blog/3VPo/a-new-approach-for-parallax-mapping-presenting-the-contact-refinement-parallax-mapping-technique

            // Based on the rough approximation, rolling back to the previous step along the ray.
            parallaxOffset -= delta;
            currentStep -= step;
            currentSample = prevSample;

            // Adjust precision
            float3 adjustedDelta = delta * step;
            float adjustedStep = step * step;

            // Uses another loop with the same step numbers, this times only covers the distance between previous point and the rough intersection point.
            while(currentSample > currentStep)
            {
                currentStep += adjustedStep;
                parallaxOffset += adjustedDelta;
                prevSample = currentSample;

                currentSample = isSingleChannel ? 
                    SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).r: 
                    SampleTex2D(Get(heightMap), Get(materialSampler), uv.xy + parallaxOffset.xy).a; 
                //currentSample = GetNormalizedDepth(depthSearchStart, depthSearchEnd, inverseDepthFactor, uv + parallaxOffset.xy, ddx_uv, ddy_uv);
            }
        }
        if(parallaxOffset.z > 0.0)
        {
            parallaxOffset = float3(0,0,0);
        }
        texCoord.xy += parallaxOffset.xy;
    }
//    if(HasHeight(Get(uniformMaterialBuffer)[materialID].materialConfig)) {
//        texCoord.xy  = ParallaxRelief(
//            SEARCH_SAMPLE_COUNT, 
//            IsHeightMapSingleChannel(Get(uniformMaterialBuffer)[materialID].materialConfig), 
//            Get(uniformMaterialBuffer)[materialID].heightMapScale * PARALAX_MULTIPLIER, 
//            normalize(In.normal), 
//            texCoord, 
//            normalize(In.view), 
//            Get(materialSampler), 
//            Get(heightMap));
//    }
#endif

    float4 diffuseColor = SampleTex2D(Get(diffuseMap), Get(materialSampler), texCoord.xy);
    if(diffuseColor.w < ALPHA_REJECT ) {
        discard;
    }

    float3 normal = float3(0, 0, 0);
    if(HasNormal(Get(uniformMaterialBuffer)[materialID].materialConfig)) {
        float3 normalSample = SampleTex2D(Get(normalMap), Get(materialSampler), texCoord.xy).xyz - 0.5;
        normal = normalize(normalSample.x * In.tangent + normalSample.y * In.bitangent + normalSample.z * In.normal);
    } else {
        normal = normalize(In.normal);
    }

    if(HasCubeMap(Get(uniformMaterialBuffer)[materialID].materialConfig)) {
        float3 envUV = reflect(cameraEyeSpace, normal);
        envUV = mul(Get(invViewRotationMat), float4(envUV.xyz, 1.0)).xyz;
                    
        float4 reflectionColor = SampleTexCube(Get(cubeMap), Get(materialSampler), envUV);
        
        float afEDotN = max(dot(-cameraEyeSpace, normal),0.0);
        float fFresnel = Fresnel(afEDotN,
            Get(uniformMaterialBuffer)[materialID].frenselBias, 
            Get(uniformMaterialBuffer)[materialID].frenselPow);
        
        if(HasCubeMapAlpha(Get(uniformMaterialBuffer)[materialID].materialConfig)) {
            reflectionColor *= SampleTex2D(Get(cubeMapAlpha), Get(materialSampler), texCoord.xy).wwww;
        }
        Out.diffuse = diffuseColor + reflectionColor * fFresnel;
    } else {
        Out.diffuse = diffuseColor;
    }
    Out.normal = float4(normal.xyz, 0.0);
    Out.position = float4(In.pos.xyz, 1.0);
    if(HasSpecular(Get(uniformMaterialBuffer)[materialID].materialConfig)) {
        Out.specular = SampleTex2D(Get(specularMap), Get(materialSampler), texCoord.xy).xy;
    } else {
        Out.specular = float2(0,0);
    }

    RETURN(Out);
}
