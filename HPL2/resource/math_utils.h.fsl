#ifndef _MATH_UTILITIES_H_
#define _MATH_UTILITIES_H_

#define PI 3.141592654f

INLINE float3x3 ToNormalMat(float4x4 invModel, float4x4 invView) {
    return transpose(mul(float3x3(invModel[0].xyz, invModel[1].xyz, invModel[2].xyz), float3x3(invView[0].xyz, invView[1].xyz, invView[2].xyz)));
}

#define square(a) (a * a)

float Fresnel(float afEDotN, float afFresnelBias, float afFresnelPow)
{
    float fFacing = 1.0 - afEDotN;
    return max(afFresnelBias+ (1.0-afFresnelBias)* pow(abs(fFacing),afFresnelPow), 0.0); 
}

float3 WorldSpaceToTangent(float3 dir, float3 normal, float3 tangent, float3 bitangent)
{
    float a = dot(tangent, dir);
    float b = dot(bitangent, dir);
    float c = dot(normal, dir);

    return float3(a,b,c);
}

float Lambert(float3 normal, float3 lightIncident)
{
    return max(0, -dot(normal, lightIncident)) / PI;
}

float Schlick_Fresnel(float F0, float VdotH)
{
    return F0 + (1 - F0) * pow(max(1 - VdotH, 0), 5);
}

float3 Schlick_FresnelF3(float3 F0, float VdotH)
{
    return F0 + (1 - F0) * pow(max(1 - VdotH, 0), 5);
}

float3 slerp(float3 a, float3 b, float angle, float t)
{
    t = saturate(t);
    float sin1 = sin(angle * t);
    float sin2 = sin(angle * (1 - t));
    float ta = sin1 / (sin1 + sin2);
    float3 result = lerp(a, b, ta);
    return normalize(result);
}

float SpecPowerToRoughness(in float s) {
    return clamp(sqrt(max(0, 2.0f / (s + 2.0f))), 0, 1);
}


float3 GGX_AnalyticalLights_times_NdotL(float3 lightIncident, float3 viewIncident, float3 normal, float roughness, float3 specularF0, float halfAngularSize)
{
    float3 N = normal;
    float3 V = -viewIncident;
    float3 L = -lightIncident;
    float3 R = reflect(viewIncident, N);

    // Correction of light vector L for spherical / directional area lights.
    // Inspired by "Real Shading in Unreal Engine 4" by B. Karis, 
    // re-formulated to work in spherical coordinates instead of world space.
    float AngleLR = acos(clamp(dot(R, L), -1, 1));

    float3 CorrectedL = (AngleLR > 0) ? slerp(L, R, AngleLR, saturate(halfAngularSize / AngleLR)) : L;
    float3 H = normalize(CorrectedL + V);

    float NdotH = saturate(dot(N, H));
    float NdotL = saturate(dot(N, CorrectedL));
    float NdotV = saturate(dot(N, V));
    float VdotH = saturate(dot(V, H));

    float Alpha = max(0.01, roughness * roughness);

    // Normalization for the widening of D, see the paper referenced above.
    float CorrectedAlpha = saturate(Alpha + 0.5 * tan(halfAngularSize));
    float SphereNormalization = square(Alpha / CorrectedAlpha);

    // GGX / Trowbridge-Reitz NDF with normalization for sphere lights
    float D = square(Alpha) / (PI * square(square(NdotH) * (square(Alpha) - 1) + 1)) * SphereNormalization;

    // Schlick model for geometric attenuation
    // The (NdotL * NdotV) term in the numerator is cancelled out by the same term in the denominator of the final result.
    float k = square(roughness + 1) / 8.0;
    float G = 1 / ((NdotL * (1 - k) + k) * (NdotV * (1 - k) + k));

    float3 F = Schlick_FresnelF3(specularF0, VdotH);

    return F * (D * G * NdotL/ 4);
}



// https://bartwronski.com/2017/04/13/cull-that-cone/
float4 boundingSphereForSpotlight(in float3 origin, in float3 forward, in float size, in float angle)
{
    float4 boundingSphere;
    if(angle > PI/4.0f)
    {
        boundingSphere.xyz = origin + cos(angle) * size * forward;
        boundingSphere.w   = sin(angle) * size;
    }
    else
    {
        boundingSphere.xyz = origin + size / (2.0f * cos(angle)) * forward;
        boundingSphere.w   = size / (2.0f * cos(angle));
    }
 
    return boundingSphere;
}

// ref: https://realtimecollisiondetection.net/books/rtcd/
// ref: https://gamedev.stackexchange.com/questions/156870/how-do-i-implement-a-aabb-sphere-collision
float sqDistPointAABB(float3 p, float3 start, float3 end) {
    float sqDist = 0.0f;
    if(p.x < start.x) sqDist += pow(start.x - p.x, 2);
    if(p.x > end.x) sqDist += pow(p.x - end.x, 2);
    if(p.y < start.y) sqDist += pow(start.y - p.y, 2);
    if(p.y > end.y) sqDist += pow(p.y - end.y, 2);
    if(p.z < start.z) sqDist += pow(start.z - p.z, 2);
    if(p.z > end.z) sqDist += pow(p.z - end.z, 2);
    return sqDist;
}

bool testSphereAABB(float3 p, float radius,float3 min, float3 max) {
    return sqDistPointAABB(p, min, max) <= (radius * radius);
}

float4 ndcToViewSpace(float4 ndc, float4x4 inverseProjection) {
    float4 view = mul(inverseProjection, ndc);
    view = view / view.w;
    return view;
}

float3 lineIntersectionToZPlane(float3 start, float3 end, float zDistance){
    const float3 normal = float3(0.0, 0.0, 1.0);
    const float3 dir =  end - start;
    const float t = (zDistance - dot(normal, start)) / dot(normal, dir);
    return start + t * dir;
}


// http://www.aortiz.me/2018/12/21/CG.html#clustered-shading
// 
float getDepthClipPlane(float slice, float numSlices, float zNear, float zFar) {
    return zNear * pow(zFar / zNear, slice / numSlices);
}


uint calcDepthSlice(float numSlices, float depth, float zNear, float zFar) {
    return uint(floor((log(depth) * (numSlices / log(zFar/zNear))) - ((numSlices * log(zNear))/log(zFar/zNear))));
}

#endif
