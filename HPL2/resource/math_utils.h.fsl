#ifndef _MATH_UTILITIES_H_
#define _MATH_UTILITIES_H_

#define PI 3.141592654f

INLINE float3x3 ToNormalMat(float4x4 invModel, float4x4 invView) {
    return transpose(mul(float3x3(invModel[0].xyz, invModel[1].xyz, invModel[2].xyz), float3x3(invView[0].xyz, invView[1].xyz, invView[2].xyz)));
}

float Fresnel(float afEDotN, float afFresnelBias, float afFresnelPow)
{
    float fFacing = 1.0 - afEDotN;
    return max(afFresnelBias+ (1.0-afFresnelBias)* pow(abs(fFacing),afFresnelPow), 0.0); 
}

float3 WorldSpaceToTangent(float3 dir, float3 normal, float3 tangent, float3 bitangent)
{
    float a = dot(tangent, dir);
    float b = dot(bitangent, dir);
    float c = dot(normal, dir);

    return float3(a,b,c);
}

// https://bartwronski.com/2017/04/13/cull-that-cone/
float4 boundingSphereForSpotlight(in float3 origin, in float3 forward, in float size, in float angle)
{
    float4 boundingSphere;
    if(angle > PI/4.0f)
    {
        boundingSphere.xyz = origin + cos(angle) * size * forward;
        boundingSphere.w   = sin(angle) * size;
    }
    else
    {
        boundingSphere.xyz = origin + size / (2.0f * cos(angle)) * forward;
        boundingSphere.w   = size / (2.0f * cos(angle));
    }
 
    return boundingSphere;
}

// ref: https://realtimecollisiondetection.net/books/rtcd/
// ref: https://gamedev.stackexchange.com/questions/156870/how-do-i-implement-a-aabb-sphere-collision
float sqDistPointAABB(float3 p, float3 start, float3 end) {
    float sqDist = 0.0f;
    if(p.x < start.x) sqDist += pow(start.x - p.x, 2);
    if(p.x > end.x) sqDist += pow(p.x - end.x, 2);
    if(p.y < start.y) sqDist += pow(start.y - p.y, 2);
    if(p.y > end.y) sqDist += pow(p.y - end.y, 2);
    if(p.z < start.z) sqDist += pow(start.z - p.z, 2);
    if(p.z > end.z) sqDist += pow(p.z - end.z, 2);
    return sqDist;
}

bool testSphereAABB(float3 p, float radius,float3 min, float3 max) {
    return sqDistPointAABB(p, min, max) <= (radius * radius);
}

float4 ndcToViewSpace(float4 ndc, float4x4 inverseProjection) {
    float4 view = mul(inverseProjection, ndc);
    view = view / view.w;
    return view;
}

float3 lineIntersectionToZPlane(float3 start, float3 end, float zDistance){
    const float3 normal = float3(0.0, 0.0, 1.0);
    const float3 dir =  end - start;
    const float t = (zDistance - dot(normal, start)) / dot(normal, dir);
    return start + t * dir;
}


// http://www.aortiz.me/2018/12/21/CG.html#clustered-shading
// 
float getDepthClipPlane(float slice, float numSlices, float zNear, float zFar) {
    return zNear * pow(zFar / zNear, slice / numSlices);
}


uint calcDepthSlice(float numSlices, float depth, float zNear, float zFar) {
    return uint(floor((log(depth) * (numSlices / log(zFar/zNear))) - ((numSlices * log(zNear))/log(zFar/zNear))));
}

float2 OctWrap(float2 v)
{
	return (1.0 - abs(v.yx)) * float2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);
}

float3 decodeDir(float2 encN)
{
	encN = encN * 2.0 - 1.0;

	float3 n;
	n.z = 1.0 - abs(encN.x) - abs(encN.y);
	n.xy = n.z >= 0.0 ? encN.xy : OctWrap(encN.xy);
	n = normalize(n);
	return n;
}

float2 encodeDir(float3 n)
{
	n /= (abs(n.x) + abs(n.y) + abs(n.z));
	n.xy = n.z >= 0.0 ? n.xy : OctWrap(n.xy);
	n.xy = n.xy * 0.5 + 0.5;
	return n.xy;
}

float2 sign_not_zero(float2 v)
{
	return step(0.0, v) * 2.0 - float2(1, 1);
}

#if !defined(VULKAN) && !defined(METAL)
	uint packSnorm2x16(float2 v)
	{
		uint2 SNorm = uint2(round(clamp(v, -1, 1) * 32767.0));
		return (0x0000FFFF & SNorm.x) | ((SNorm.y << 16) & 0xFFFF0000);
	}

	float2 unpackSnorm2x16(uint p)
	{
		half2 ret = half2(
			clamp((0x0000FFFF & p) / 32767.0, -1, 1),
			clamp(((0xFFFF0000 & p) >> 16) / 32767.0, -1, 1)
		);

		return ret;
	}

	uint packUnorm2x16(float2 v)
	{
		uint2 UNorm = uint2(round(saturate(v) * 65535.0));
		return (0x0000FFFF & UNorm.x) | ((UNorm.y << 16) & 0xFFFF0000);
	}

	float2 unpackUnorm2x16(uint p)
	{
		float2 ret;
		ret.x = saturate((0x0000FFFF & p) / 65535.0);
		ret.y = saturate(((0xFFFF0000 & p) >> 16) / 65535.0);
		return ret;
	}


	uint packUnorm4x8(float4 v)
	{
		uint4 UNorm = uint4(round(saturate(v) * 255.0));
		return (0x000000FF & UNorm.x) | ((UNorm.y << 8) & 0x0000FF00) | ((UNorm.z << 16) & 0x00FF0000) | ((UNorm.w << 24) & 0xFF000000);
	}

	float4 unpackUnorm4x8(uint p)
	{
		return float4(float(p & 0x000000FF) / 255.0,
			float((p & 0x0000FF00) >> 8) / 255.0,
			float((p & 0x00FF0000) >> 16) / 255.0,
			float((p & 0xFF000000) >> 24) / 255.0);
	}
#endif

#ifndef METAL
	uint pack2Floats(float low, float high)
	{
	#ifdef VULKAN
		return packHalf2x16(vec2(low, high));
	#else
		return uint((f32tof16(low) & 0xFFFF) | ((f32tof16(high) & 0xFFFF) << 16));
	#endif
	}

	float2 unpack2Floats(uint p)
	{
	#ifdef VULKAN
		return unpackHalf2x16(p);
	#else
		return float2(f16tof32(p & 0xFFFF), f16tof32((p >> 16) & 0xFFFF));
	#endif
	}

	uint pack2Snorms(float low, float high)
	{
	#ifdef VULKAN
		return packSnorm2x16(vec2(low, high));
	#else
		return packSnorm2x16(half2(low, high));
	#endif
	}

	float2 unpack2Snorms(uint p)
	{
		return float2(unpackSnorm2x16(p));
	}

	uint pack2Unorms(float low, float high)
	{
	#ifdef VULKAN
		return packUnorm2x16(vec2(low, high));
	#else
		return packUnorm2x16(half2(low, high));
	#endif
	}

	float2 unpack2Unorms(uint p)
	{
		return float2(unpackUnorm2x16(p));
	}
#else
	float2 unpack2Floats(uint p)
	{
		return float2(as_type<half2>(p));
	}
	#define unpackUnorm2x16 unpack_unorm2x16_to_float
	#define packUnorm4x8    pack_float_to_unorm4x8
	#define unpackUnorm4x8  unpack_unorm4x8_to_float
#endif // METAL

#endif
